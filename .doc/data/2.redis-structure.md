# Redis 데이터 구조
## 재고 감소
```redis
# Key Pattern
inventory:{productId}

# Type: String (숫자로 사용)
# Value: 현재 가용 재고 수량
GET inventory:65a1b2c3d4e5f6789abcdef0
=> "953"

# 원자적 감소
DECR inventory:65a1b2c3d4e5f6789abcdef0
=> 952

# 조건부 감소 (Lua Script)
EVAL """
  local stock = redis.call('GET', KEYS[1])
  if tonumber(stock) > 0 then
    return redis.call('DECR', KEYS[1])
  else
    return -1
  end
""" 1 inventory:65a1b2c3d4e5f6789abcdef0
```

## 예약
```redis
# 임시 예약 (10분 타임아웃)
# Key: inventory:reserved:{orderId}
SETEX inventory:reserved:order123 600 1

# 예약 수량 집계 (Sorted Set)
# Key: inventory:reservations:{productId}
# Score: 만료 시각 (timestamp)
# Member: orderId
ZADD inventory:reservations:65a1b2c3d4e5f6789abcdef0 1697184545 order123

# 만료된 예약 정리
ZREMRANGEBYSCORE inventory:reservations:65a1b2c3d4e5f6789abcdef0 0 {currentTimestamp}
```

## 분산 락 (동시성 제어)
```redis
# Key: inventory:lock:{productId}
# Value: 락 소유자 ID (UUID)
# TTL: 10초

# 락 획득 (NX: Not eXists, EX: 초 단위 TTL)
SET inventory:lock:65a1b2c3d4e5f6789abcdef0 uuid-12345 NX EX 10
=> OK (성공) 또는 nil (실패)

# 락 해제 (소유자 확인 후)
EVAL """
  if redis.call('GET', KEYS[1]) == ARGV[1] then
    return redis.call('DEL', KEYS[1])
  else
    return 0
  end
""" 1 inventory:lock:65a1b2c3d4e5f6789abcdef0 uuid-12345
```

# 재고 감소 플로우

## 기본 플로우 (낙관적)
```
1. 클라이언트: 주문 요청
   └→ GraphQL Mutation: createOrder(productId, quantity)

2. 서버: Redis 재고 확인 및 감소
   ├→ GET inventory:{productId}
   │  └→ if stock >= quantity
   │     ├→ DECRBY inventory:{productId} {quantity}
   │     └→ 성공 → 단계 3
   │  └→ else
   │     └→ 실패 → "품절" 응답

3. 주문 생성 및 예약
   ├→ MongoDB: Order 생성 (status: pending)
   ├→ Redis: 예약 기록
   │  └→ ZADD inventory:reservations:{productId} {expiry} {orderId}
   └→ Kafka: OrderCreated 이벤트 발행

4. 비동기 처리 (Kafka Consumer)
   ├→ 결제 처리
   ├→ 성공 → Order.status = confirmed
   │  └→ MongoDB: Inventory.sold += quantity
   └→ 실패 → 재고 복구
      ├→ INCRBY inventory:{productId} {quantity}
      └→ ZREM inventory:reservations:{productId} {orderId}
```

## 분산 락 플로우 (비관적)
```
1. 락 획득 시도
   └→ SET inventory:lock:{productId} {uuid} NX EX 10
      ├→ 성공 → 단계 2
      └→ 실패 → 재시도 (최대 3회) 또는 에러

2. 재고 확인 및 감소 (락 보호)
   └→ GET inventory:{productId}
      └→ if stock >= quantity
         └→ DECRBY inventory:{productId} {quantity}

3. 주문 생성 (동일)

4. 락 해제
   └→ DEL inventory:lock:{productId} (소유자 확인)
```

# Redis-MongoDB 동기화

```javascript
// Kafka Topic: inventory.sync
{
  productId: "65a1b2c3d4e5f6789abcdef0",
  action: "decrease",
  amount: 1,
  redisValue: 952,
  timestamp: "2025-10-13T10:30:00Z"
}

// Consumer
async function syncInventory(event) {
  await db.inventory.updateOne(
    { productId: event.productId },
    {
      $set: {
        'redis.currentValue': event.redisValue,
        'redis.lastSyncedAt': new Date(),
        'stock.available': event.redisValue
      },
      $inc: {
        'redis.syncVersion': 1
      }
    }
  );
  
  // 레벨 재계산
  await updateInventoryLevel(event.productId);
}
```

## 동기화 충돌 해결

### 낙관적 락 (Optimistic Locking)
```javascript
async function syncWithVersion(productId, redisValue) {
  const inventory = await db.inventory.findOne({ productId });
  
  const result = await db.inventory.updateOne(
    {
      productId,
      'redis.syncVersion': inventory.redis.syncVersion  // 버전 체크
    },
    {
      $set: {
        'redis.currentValue': redisValue,
        'redis.lastSyncedAt': new Date()
      },
      $inc: {
        'redis.syncVersion': 1
      }
    }
  );
  
  if (result.modifiedCount === 0) {
    // 버전 충돌 → 재시도
    console.warn('Sync version conflict, retrying...');
    return syncWithVersion(productId, redisValue);
  }
}
```

# 장애 복구 시나리오

## Redis 장애
```javascript
async function handleRedisFailure(productId, quantity) {
  console.error('Redis failure detected');
  
  // Fallback: MongoDB로 재고 관리 (성능 저하)
  const session = await db.startSession();
  
  try {
    await session.withTransaction(async () => {
      const inventory = await db.inventory.findOne(
        { productId },
        { session }
      );
      
      if (inventory.stock.available < quantity) {
        throw new Error('INSUFFICIENT_STOCK');
      }
      
      await db.inventory.updateOne(
        { productId },
        {
          $inc: {
            'stock.available': -quantity,
            'stock.reserved': quantity
          }
        },
        { session }
      );
    });
    
    return { success: true };
  } catch (error) {
    return { success: false, error };
  } finally {
    await session.endSession();
  }
}
```

## MongoDB 장애
```javascript
// Redis는 계속 동작 (재고 감소)
// MongoDB 복구 후 재동기화

async function reconcileAfterMongoDBFailure() {
  const redisKeys = await redis.keys('inventory:*');
  
  for (const key of redisKeys) {
    const productId = key.split(':')[1];
    const redisValue = await redis.get(key);
    
    // MongoDB 값과 비교
    const inventory = await db.inventory.findOne({ productId });
    
    if (!inventory) {
      console.warn(`Inventory not found for ${productId}`);
      continue;
    }
    
    const diff = redisValue - inventory.redis.currentValue;
    
    if (diff !== 0) {
      // 차이만큼 조정
      await db.inventory.updateOne(
        { productId },
        {
          $inc: {
            'stock.sold': -diff,  // Redis가 감소했으므로 sold 증가
            'stock.available': diff
          },
          $set: {
            'redis.currentValue': parseInt(redisValue),
            'redis.lastSyncedAt': new Date()
          }
        }
      );
      
      console.log(`Reconciled ${productId}: diff=${diff}`);
    }
  }
}
```

## 동기화 불일치 감지
```javascript
// Health Check
async function checkInventoryConsistency() {
  const inventories = await db.inventory.find({}).limit(100);
  const inconsistencies = [];
  
  for (const inv of inventories) {
    const redisValue = await redis.get(inv.redis.key);
    
    if (redisValue === null) {
      inconsistencies.push({
        productId: inv.productId,
        issue: 'REDIS_KEY_MISSING',
        mongo: inv.redis.currentValue,
        redis: null
      });
      continue;
    }
    
    const diff = Math.abs(parseInt(redisValue) - inv.redis.currentValue);
    
    if (diff > 10) {  // 10개 이상 차이
      inconsistencies.push({
        productId: inv.productId,
        issue: 'LARGE_DISCREPANCY',
        mongo: inv.redis.currentValue,
        redis: parseInt(redisValue),
        diff
      });
    }
  }
  
  if (inconsistencies.length > 0) {
    // 알림 발송
    await sendAlert('inventory.inconsistency', inconsistencies);
  }
  
  return inconsistencies;
}
```

