# Kafka 이벤트 설계

## Topic 구조
```
orders.created          → 주문 생성
orders.updated          → 주문 상태 변경
orders.cancelled        → 주문 취소
orders.completed        → 주문 완료

payments.pending        → 결제 대기
payments.completed      → 결제 완료
payments.failed         → 결제 실패
payments.refunded       → 환불 완료

inventory.reserved      → 재고 예약
inventory.released      → 재고 해제
inventory.confirmed     → 재고 확정

notifications.email     → 이메일 알림
notifications.push      → 푸시 알림
notifications.sms       → SMS 알림
```

## 이벤트 스키마

### OrderCreated
```javascript
{
  eventId: "evt-65a1b2c3d4e5f6789abcdef0",  // 멱등성
  eventType: "OrderCreated",
  eventVersion: "1.0",
  timestamp: "2025-10-13T10:30:00Z",
  
  // 주문 정보
  order: {
    orderId: "65a1b2c3d4e5f6789abcdef0",
    orderNumber: "FD-20251013-A7B3C9",
    userId: "user123",
    
    items: [
      {
        productId: "65a1b2c3d4e5f6789abcdef1",
        quantity: 2,
        unitPrice: 89.00
      }
    ],
    
    total: 187.99,
    currency: "USD"
  },
  
  // 메타데이터
  metadata: {
    source: "web",
    correlationId: "corr-123",  // 분산 추적
    causationId: "cause-456"    // 원인 이벤트
  }
}
```

### PaymentCompleted
```javascript
{
  eventId: "evt-...",
  eventType: "PaymentCompleted",
  eventVersion: "1.0",
  timestamp: "2025-10-13T10:30:15Z",
  
  payment: {
    orderId: "65a1b2c3d4e5f6789abcdef0",
    amount: 187.99,
    currency: "USD",
    method: "card",
    transactionId: "pi_3O1K2lJKLMNOPQRS",
    gateway: "Stripe"
  },
  
  metadata: {
    correlationId: "corr-123"
  }
}
```

### InventoryReserved
```javascript
{
  eventId: "evt-...",
  eventType: "InventoryReserved",
  eventVersion: "1.0",
  timestamp: "2025-10-13T10:30:01Z",
  
  inventory: {
    productId: "65a1b2c3d4e5f6789abcdef1",
    quantity: 2,
    orderId: "65a1b2c3d4e5f6789abcdef0",
    expiresAt: "2025-10-13T10:40:00Z"  // 10분 후
  }
}
```

# 주문 생성 플로우

## 성공 시나리오
```
1. 클라이언트: createOrder Mutation
   └→ GraphQL Server

2. 주문 검증 및 생성 (동기)
   ├→ 멱등성 키 확인 (중복 방지)
   ├→ 재고 확인 (Redis GET)
   ├→ 주문 생성 (MongoDB, status: pending)
   └→ 응답: { orderId, status: "pending" }

3. 이벤트 발행 (비동기)
   ├→ Kafka: OrderCreated
   └→ Kafka: InventoryReserveRequested

4. Consumer 1: Inventory Service
   ├→ Redis DECR (재고 감소)
   ├→ 성공 → Kafka: InventoryReserved
   └→ 실패 → Kafka: InventoryReserveFailed
      └→ Compensate: Order.status = "failed"

5. Consumer 2: Payment Service
   ├→ 결제 처리 (외부 API)
   ├→ 성공 → Kafka: PaymentCompleted
   │  └→ Order.status = "confirmed"
   │  └→ Kafka: InventoryConfirmed
   └→ 실패 → Kafka: PaymentFailed
      └→ Compensate: 
         ├→ Redis INCR (재고 복구)
         └→ Order.status = "failed"

6. Consumer 3: Notification Service
   ├→ 이메일 발송
   └→ SMS 발송 (선택)
```

## 실패 시나리오 (보상 트랜잭션)

### 재고 부족
```
1. createOrder
2. Redis GET → stock = 0
3. 즉시 응답: { error: "INSUFFICIENT_STOCK" }
   (Kafka 이벤트 발행 안 함)
```

### 결제 실패
```
1-3. 정상 진행
4. Inventory 예약 성공
5. Payment 실패
   └→ Kafka: PaymentFailed
6. Compensating Action
   ├→ Redis INCR (재고 복구)
   ├→ Order.status = "failed"
   └→ Kafka: OrderFailed
```

### Timeout
```
1-3. 정상 진행
4. Inventory 예약 성공 (10분 TTL)
5. Payment 처리 중... (타임아웃)
6. TTL 만료 → Redis 자동 복구
   OR
   Scheduled Job이 만료된 예약 정리
   ├→ ZRANGEBYSCORE (만료된 예약 조회)
   ├→ Redis INCR (재고 복구)
   └→ Order.status = "cancelled"
```

# 멱등성 처리

## Idempotency Key
```javascript
// 클라이언트 생성
const idempotencyKey = `idem-${userId}-${timestamp}-${randomString}`;

// GraphQL Mutation
mutation CreateOrder {
  createOrder(
    input: { ... }
    idempotencyKey: "idem-user123-1697184600-abc"
  ) {
    orderId
    status
  }
}

// 서버 검증
async function createOrder(input, idempotencyKey) {
  const existing = await db.orders.findOne({ idempotencyKey });
  
  if (existing) {
    // 이미 처리된 요청
    return {
      orderId: existing._id,
      status: existing.status,
      isDuplicate: true
    };
  }
  
  // 새 주문 생성
  const order = await db.orders.insertOne({
    ...input,
    idempotencyKey,
    status: "pending"
  });
  
  return {
    orderId: order._id,
    status: "pending",
    isDuplicate: false
  };
}
```

## Kafka 이벤트 멱등성
```javascript
// Producer: eventId로 중복 방지
const eventId = `evt-${orderId}-OrderCreated`;

await kafka.send({
  topic: 'orders.created',
  key: orderId,  // 파티션 키
  value: {
    eventId,  // 멱등성 키
    eventType: 'OrderCreated',
    // ...
  }
});

// Consumer: eventId 확인
async function handleOrderCreated(event) {
  const processed = await db.processed_events.findOne({
    eventId: event.eventId
  });
  
  if (processed) {
    console.log('Event already processed:', event.eventId);
    return;  // 중복 처리 스킵
  }
  
  // 처리
  await processOrder(event.order);
  
  // 처리 완료 기록
  await db.processed_events.insertOne({
    eventId: event.eventId,
    processedAt: new Date()
  });
}
```

# 주문 상태 머신

## 상태 전이
```
pending → processing → confirmed → shipped → delivered
   ↓          ↓            ↓           ↓
 failed    failed      cancelled   cancelled
```

## 상태별 허용 작업
```javascript
const stateTransitions = {
  pending: ['processing', 'failed', 'cancelled'],
  processing: ['confirmed', 'failed'],
  confirmed: ['shipped', 'cancelled'],
  shipped: ['delivered', 'cancelled'],
  delivered: [],  // 종료 상태
  failed: [],     // 종료 상태
  cancelled: []   // 종료 상태
};

function canTransition(from, to) {
  return stateTransitions[from]?.includes(to) ?? false;
}

// 상태 변경
async function updateOrderStatus(orderId, newStatus, reason, actor) {
  const order = await db.orders.findOne({ _id: orderId });
  
  if (!canTransition(order.status, newStatus)) {
    throw new Error(`Invalid transition: ${order.status} → ${newStatus}`);
  }
  
  await db.orders.updateOne(
    { _id: orderId },
    {
      $set: { status: newStatus, updatedAt: new Date() },
      $push: {
        statusHistory: {
          from: order.status,
          to: newStatus,
          timestamp: new Date(),
          reason,
          actor
        }
      }
    }
  );
  
  // 이벤트 발행
  await kafka.send({
    topic: 'orders.updated',
    value: {
      orderId,
      oldStatus: order.status,
      newStatus,
      reason
    }
  });
}
```


# 부분 취소/환불

## 부분 취소
```javascript
{
  _id: ObjectId("..."),
  status: "partially_cancelled",  // 새 상태
  
  items: [
    {
      productId: ObjectId("..."),
      quantity: 2,
      status: "confirmed",  // 정상
      // ...
    },
    {
      productId: ObjectId("..."),
      quantity: 1,
      status: "cancelled",  // 취소됨
      // ...
    }
  ],
  
  cancellation: {
    isCancelled: false,  // 전체는 아님
    isPartial: true,
    
    items: [
      {
        productId: ObjectId("..."),
        quantity: 1,
        reason: "고객 요청",
        cancelledBy: "user",
        cancelledAt: ISODate("..."),
        refundAmount: 89.00
      }
    ],
    
    totalRefund: 89.00
  }
}
```