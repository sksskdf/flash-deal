# Order 도메인 모델 상세

## 1. 설계 철학

### 이벤트 기반 비동기 처리
- **동기 처리**: 주문 생성, 재고 예약 (빠른 응답)
- **비동기 처리**: 결제, 재고 확정, 알림 (안정성)
- **Kafka**: 주문 이벤트 버퍼, 트래픽 완충

### 핵심 원칙
1. **Write Optimized**: 임베디드 문서로 조회 최적화
2. **Event Sourcing**: 상태 변경 이력 추적
3. **Idempotency**: 중복 처리 방지
4. **Saga Pattern**: 분산 트랜잭션 관리



## 2. MongoDB 스키마

### 2.1 Orders 컬렉션
```javascript
{
  _id: ObjectId("65a1b2c3d4e5f6789abcdef0"),
  orderNumber: "FD-20251013-A7B3C9",  // 사용자 친화적 ID
  
  // === 사용자 정보 (비정규화) ===
  user: {
    id: "user123",           // 외부 User ID (인증 시스템)
    email: "user@example.com",
    name: "홍길동",
    phone: "+82-10-1234-5678"  // 동적 추가
  },
  
  // === 주문 상품 (완전 비정규화 - 스냅샷) ===
  items: [
    {
      productId: ObjectId("..."),
      dealType: "flash",     // 주문 시점의 딜 타입
      
      // 주문 시점 스냅샷 (Product 변경돼도 유지)
      snapshot: {
        title: "무선 노이즈 캔슬링 헤드폰",
        subtitle: "프리미엄 오디오 경험",
        image: "https://cdn.example.com/products/headphone.jpg",
        category: "전자기기",
        
        price: {
          original: 299.00,
          sale: 89.00,
          currency: "USD",
          rate: 70
        },
        
        // 주문 시점의 동적 속성
        specs: {
          color: "Black",
          warranty: "2 years",
          // ... 필요한 스펙만 스냅샷
        },
        
        // 주문 시 선택한 옵션
        selectedOptions: {
          color: "Black",
          warranty: "Extended 3 years (+$20)"
        }
      },
      
      quantity: 2,
      unitPrice: 89.00,
      subtotal: 178.00,  // quantity * unitPrice
      
      // 개별 상품 상태 (선택)
      status: "confirmed",  // pending | confirmed | shipped | cancelled
      
      // 배송 추적 (선택)
      tracking: {
        carrier: "UPS",
        trackingNumber: "1Z999AA10123456784",
        shippedAt: ISODate("2025-10-14T00:00:00Z"),
        estimatedDelivery: ISODate("2025-10-17T00:00:00Z")
      }
    }
  ],
  
  // === 주문 금액 ===
  pricing: {
    subtotal: 178.00,       // items 합계
    shipping: 9.99,
    tax: 0.00,
    discount: 0.00,         // 쿠폰, 프로모션
    total: 187.99,          // 최종 금액
    currency: "USD",
    
    // 동적 추가 가능
    breakdown: {
      productTotal: 178.00,
      shippingBase: 9.99,
      shippingDiscount: 0.00,
      couponDiscount: 0.00,
      pointsUsed: 0.00
    }
  },
  
  // === 배송 정보 ===
  shipping: {
    method: "standard",  // standard | express | overnight
    
    recipient: {
      name: "홍길동",
      phone: "+82-10-1234-5678"
    },
    
    address: {
      type: "home",  // home | office | other
      street: "123 Main St",
      street2: "Apt 4B",
      city: "Seoul",
      state: "Seoul",
      zipCode: "12345",
      country: "KR",
      
      // 동적 추가
      coordinates: {
        lat: 37.5665,
        lng: 126.9780
      }
    },
    
    instructions: "문 앞에 놔주세요",  // 동적 추가
    preferredTime: "오후 2-6시"      // 동적 추가
  },
  
  // === 결제 정보 ===
  payment: {
    method: "card",  // card | paypal | bank_transfer | crypto
    
    // 카드 정보 (마스킹)
    card: {
      last4: "1234",
      brand: "Visa",
      expiryMonth: 12,
      expiryYear: 2025
    },
    
    status: "completed",  // pending | processing | completed | failed | refunded
    
    // 결제 게이트웨이 정보
    gateway: {
      provider: "Stripe",
      transactionId: "pi_3O1K2lJKLMNOPQRS",
      receiptUrl: "https://stripe.com/receipts/...",
      chargedAt: ISODate("2025-10-13T10:30:15Z")
    },
    
    // 환불 정보 (선택)
    refund: {
      amount: 0.00,
      reason: null,
      refundedAt: null,
      transactionId: null
    },
    
    // 동적 추가 (예: 할부)
    installment: {
      months: 3,
      monthlyAmount: 62.66,
      interestRate: 0.0
    }
  },
  
  // === 주문 상태 ===
  status: "confirmed",  // pending | processing | confirmed | shipped | delivered | cancelled | failed
  
  // === 상태 변경 이력 (Event Sourcing) ===
  statusHistory: [
    {
      from: null,
      to: "pending",
      timestamp: ISODate("2025-10-13T10:30:00Z"),
      reason: "Order created",
      actor: "system",
      
      // 동적 메타데이터
      metadata: {
        source: "web",
        ip: "192.168.1.1",
        userAgent: "Mozilla/5.0..."
      }
    },
    {
      from: "pending",
      to: "processing",
      timestamp: ISODate("2025-10-13T10:30:05Z"),
      reason: "Payment processing started",
      actor: "payment-service",
      metadata: {
        paymentMethod: "card",
        processor: "Stripe"
      }
    },
    {
      from: "processing",
      to: "confirmed",
      timestamp: ISODate("2025-10-13T10:30:15Z"),
      reason: "Payment completed",
      actor: "payment-service",
      metadata: {
        transactionId: "pi_3O1K2lJKLMNOPQRS"
      }
    }
  ],
  
  // === Kafka 이벤트 추적 ===
  kafkaEvents: [
    {
      eventType: "OrderCreated",
      topic: "orders.created",
      partition: 2,
      offset: 12345,
      publishedAt: ISODate("2025-10-13T10:30:01Z"),
      
      // 이벤트 페이로드 (선택)
      payload: {
        orderId: "65a1b2c3d4e5f6789abcdef0",
        userId: "user123",
        total: 187.99
      }
    },
    {
      eventType: "PaymentCompleted",
      topic: "payments.completed",
      partition: 1,
      offset: 67890,
      publishedAt: ISODate("2025-10-13T10:30:16Z")
    }
  ],
  
  // === 멱등성 키 ===
  idempotencyKey: "idem-user123-1697184600-abc",  // 중복 주문 방지
  
  // === 취소/환불 정보 ===
  cancellation: {
    isCancelled: false,
    reason: null,
    cancelledBy: null,  // user | admin | system
    cancelledAt: null,
    
    // 부분 취소 (선택)
    items: []
  },
  
  // === 메타데이터 (동적 확장) ===
  metadata: {
    source: "web",           // web | mobile | api
    device: "desktop",
    campaign: "flash-deal-oct",
    referrer: "https://ads.google.com/...",
    
    // A/B 테스트
    experiments: {
      checkoutFlow: "variant-B",
      pricingDisplay: "control"
    },
    
    // 고객 세그먼트
    customerSegment: "VIP",
    loyaltyPoints: 1000,
    
    // 향후 추가 가능한 필드들...
    giftMessage: "Happy Birthday!",
    giftWrap: true,
    
    // 재고 예약 정보
    reservation: {
      reservedAt: ISODate("2025-10-13T10:30:00Z"),
      expiresAt: ISODate("2025-10-13T10:40:00Z"),
      released: false
    }
  },
  
  createdAt: ISODate("2025-10-13T10:30:00Z"),
  updatedAt: ISODate("2025-10-13T10:30:15Z")
}
```



## 3. Kafka 이벤트 설계

### 3.1 Topic 구조
```
orders.created          → 주문 생성
orders.updated          → 주문 상태 변경
orders.cancelled        → 주문 취소
orders.completed        → 주문 완료

payments.pending        → 결제 대기
payments.completed      → 결제 완료
payments.failed         → 결제 실패
payments.refunded       → 환불 완료

inventory.reserved      → 재고 예약
inventory.released      → 재고 해제
inventory.confirmed     → 재고 확정

notifications.email     → 이메일 알림
notifications.push      → 푸시 알림
notifications.sms       → SMS 알림
```

### 3.2 이벤트 스키마

#### OrderCreated
```javascript
{
  eventId: "evt-65a1b2c3d4e5f6789abcdef0",  // 멱등성
  eventType: "OrderCreated",
  eventVersion: "1.0",
  timestamp: "2025-10-13T10:30:00Z",
  
  // 주문 정보
  order: {
    orderId: "65a1b2c3d4e5f6789abcdef0",
    orderNumber: "FD-20251013-A7B3C9",
    userId: "user123",
    
    items: [
      {
        productId: "65a1b2c3d4e5f6789abcdef1",
        quantity: 2,
        unitPrice: 89.00
      }
    ],
    
    total: 187.99,
    currency: "USD"
  },
  
  // 메타데이터
  metadata: {
    source: "web",
    correlationId: "corr-123",  // 분산 추적
    causationId: "cause-456"    // 원인 이벤트
  }
}
```

#### PaymentCompleted
```javascript
{
  eventId: "evt-...",
  eventType: "PaymentCompleted",
  eventVersion: "1.0",
  timestamp: "2025-10-13T10:30:15Z",
  
  payment: {
    orderId: "65a1b2c3d4e5f6789abcdef0",
    amount: 187.99,
    currency: "USD",
    method: "card",
    transactionId: "pi_3O1K2lJKLMNOPQRS",
    gateway: "Stripe"
  },
  
  metadata: {
    correlationId: "corr-123"
  }
}
```

#### InventoryReserved
```javascript
{
  eventId: "evt-...",
  eventType: "InventoryReserved",
  eventVersion: "1.0",
  timestamp: "2025-10-13T10:30:01Z",
  
  inventory: {
    productId: "65a1b2c3d4e5f6789abcdef1",
    quantity: 2,
    orderId: "65a1b2c3d4e5f6789abcdef0",
    expiresAt: "2025-10-13T10:40:00Z"  // 10분 후
  }
}
```



## 4. 주문 생성 플로우 (Saga Pattern)

### 4.1 성공 시나리오
```
1. 클라이언트: createOrder Mutation
   └→ GraphQL Server

2. 주문 검증 및 생성 (동기)
   ├→ 멱등성 키 확인 (중복 방지)
   ├→ 재고 확인 (Redis GET)
   ├→ 주문 생성 (MongoDB, status: pending)
   └→ 응답: { orderId, status: "pending" }

3. 이벤트 발행 (비동기)
   ├→ Kafka: OrderCreated
   └→ Kafka: InventoryReserveRequested

4. Consumer 1: Inventory Service
   ├→ Redis DECR (재고 감소)
   ├→ 성공 → Kafka: InventoryReserved
   └→ 실패 → Kafka: InventoryReserveFailed
      └→ Compensate: Order.status = "failed"

5. Consumer 2: Payment Service
   ├→ 결제 처리 (외부 API)
   ├→ 성공 → Kafka: PaymentCompleted
   │  └→ Order.status = "confirmed"
   │  └→ Kafka: InventoryConfirmed
   └→ 실패 → Kafka: PaymentFailed
      └→ Compensate: 
         ├→ Redis INCR (재고 복구)
         └→ Order.status = "failed"

6. Consumer 3: Notification Service
   ├→ 이메일 발송
   └→ SMS 발송 (선택)
```

### 4.2 실패 시나리오 (보상 트랜잭션)

#### 재고 부족
```
1. createOrder
2. Redis GET → stock = 0
3. 즉시 응답: { error: "INSUFFICIENT_STOCK" }
   (Kafka 이벤트 발행 안 함)
```

#### 결제 실패
```
1-3. 정상 진행
4. Inventory 예약 성공
5. Payment 실패
   └→ Kafka: PaymentFailed
6. Compensating Action
   ├→ Redis INCR (재고 복구)
   ├→ Order.status = "failed"
   └→ Kafka: OrderFailed
```

#### Timeout
```
1-3. 정상 진행
4. Inventory 예약 성공 (10분 TTL)
5. Payment 처리 중... (타임아웃)
6. TTL 만료 → Redis 자동 복구
   OR
   Scheduled Job이 만료된 예약 정리
   ├→ ZRANGEBYSCORE (만료된 예약 조회)
   ├→ Redis INCR (재고 복구)
   └→ Order.status = "cancelled"
```



## 5. 멱등성 처리

### 5.1 Idempotency Key
```javascript
// 클라이언트 생성
const idempotencyKey = `idem-${userId}-${timestamp}-${randomString}`;

// GraphQL Mutation
mutation CreateOrder {
  createOrder(
    input: { ... }
    idempotencyKey: "idem-user123-1697184600-abc"
  ) {
    orderId
    status
  }
}

// 서버 검증
async function createOrder(input, idempotencyKey) {
  const existing = await db.orders.findOne({ idempotencyKey });
  
  if (existing) {
    // 이미 처리된 요청
    return {
      orderId: existing._id,
      status: existing.status,
      isDuplicate: true
    };
  }
  
  // 새 주문 생성
  const order = await db.orders.insertOne({
    ...input,
    idempotencyKey,
    status: "pending"
  });
  
  return {
    orderId: order._id,
    status: "pending",
    isDuplicate: false
  };
}
```

### 5.2 Kafka 이벤트 멱등성
```javascript
// Producer: eventId로 중복 방지
const eventId = `evt-${orderId}-OrderCreated`;

await kafka.send({
  topic: 'orders.created',
  key: orderId,  // 파티션 키
  value: {
    eventId,  // 멱등성 키
    eventType: 'OrderCreated',
    // ...
  }
});

// Consumer: eventId 확인
async function handleOrderCreated(event) {
  const processed = await db.processed_events.findOne({
    eventId: event.eventId
  });
  
  if (processed) {
    console.log('Event already processed:', event.eventId);
    return;  // 중복 처리 스킵
  }
  
  // 처리
  await processOrder(event.order);
  
  // 처리 완료 기록
  await db.processed_events.insertOne({
    eventId: event.eventId,
    processedAt: new Date()
  });
}
```



## 6. 주문 상태 머신

### 6.1 상태 전이
```
pending → processing → confirmed → shipped → delivered
   ↓          ↓            ↓           ↓
 failed    failed      cancelled   cancelled
```

### 6.2 상태별 허용 작업
```javascript
const stateTransitions = {
  pending: ['processing', 'failed', 'cancelled'],
  processing: ['confirmed', 'failed'],
  confirmed: ['shipped', 'cancelled'],
  shipped: ['delivered', 'cancelled'],
  delivered: [],  // 종료 상태
  failed: [],     // 종료 상태
  cancelled: []   // 종료 상태
};

function canTransition(from, to) {
  return stateTransitions[from]?.includes(to) ?? false;
}

// 상태 변경
async function updateOrderStatus(orderId, newStatus, reason, actor) {
  const order = await db.orders.findOne({ _id: orderId });
  
  if (!canTransition(order.status, newStatus)) {
    throw new Error(`Invalid transition: ${order.status} → ${newStatus}`);
  }
  
  await db.orders.updateOne(
    { _id: orderId },
    {
      $set: { status: newStatus, updatedAt: new Date() },
      $push: {
        statusHistory: {
          from: order.status,
          to: newStatus,
          timestamp: new Date(),
          reason,
          actor
        }
      }
    }
  );
  
  // 이벤트 발행
  await kafka.send({
    topic: 'orders.updated',
    value: {
      orderId,
      oldStatus: order.status,
      newStatus,
      reason
    }
  });
}
```



## 7. 부분 취소/환불

### 7.1 부분 취소
```javascript
{
  _id: ObjectId("..."),
  status: "partially_cancelled",  // 새 상태
  
  items: [
    {
      productId: ObjectId("..."),
      quantity: 2,
      status: "confirmed",  // 정상
      // ...
    },
    {
      productId: ObjectId("..."),
      quantity: 1,
      status: "cancelled",  // 취소됨
      // ...
    }
  ],
  
  cancellation: {
    isCancelled: false,  // 전체는 아님
    isPartial: true,
    
    items: [
      {
        productId: ObjectId("..."),
        quantity: 1,
        reason: "고객 요청",
        cancelledBy: "user",
        cancelledAt: ISODate("..."),
        refundAmount: 89.00
      }
    ],
    
    totalRefund: 89.00
  }
}
```



## 8. 조회 패턴과 인덱스

### 8.1 주요 쿼리
```javascript
// 1. 사용자별 주문 조회
db.orders.find({
  "user.id": "user123"
}).sort({ createdAt: -1 })

// 2. 주문 번호 조회
db.orders.findOne({
  orderNumber: "FD-20251013-A7B3C9"
})

// 3. 상태별 조회 (관리자)
db.orders.find({
  status: "confirmed",
  "payment.status": "completed"
}).sort({ createdAt: -1 })

// 4. 특정 상품 주문 조회
db.orders.find({
  "items.productId": ObjectId("...")
})

// 5. 멱등성 키 조회
db.orders.findOne({
  idempotencyKey: "idem-user123-1697184600-abc"
})
```

### 8.2 인덱스
```javascript
// 사용자별 조회
db.orders.createIndex({ "user.id": 1, createdAt: -1 })

// 주문 번호
db.orders.createIndex({ orderNumber: 1 }, { unique: true })

// 상태별 조회
db.orders.createIndex({
  status: 1,
  "payment.status": 1,
  createdAt: -1
})

// 상품별 주문
db.orders.createIndex({ "items.productId": 1 })

// 멱등성
db.orders.createIndex({ idempotencyKey: 1 }, { unique: true, sparse: true })

// Kafka 추적
db.orders.createIndex({ "kafkaEvents.eventType": 1 })
```



## 9. GraphQL 통합

### 9.1 타입 정의
```graphql
type Order {
  id: ID!
  orderNumber: String!
  user: UserInfo!
  items: [OrderItem!]!
  pricing: PricingInfo!
  shipping: ShippingInfo!
  payment: PaymentInfo!
  status: OrderStatus!
  statusHistory: [StatusChange!]!
  createdAt: DateTime!
}

enum OrderStatus {
  PENDING
  PROCESSING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
  FAILED
}

type Query {
  order(id: ID!): Order
  orderByNumber(orderNumber: String!): Order
  myOrders(limit: Int, offset: Int): [Order!]!
}

type Mutation {
  createOrder(
    input: CreateOrderInput!
    idempotencyKey: String!
  ): CreateOrderResult!
  
  cancelOrder(
    orderId: ID!
    reason: String
  ): Order!
}
```



## 10. Best Practices

### 10.1 DO
✅ 상품 정보를 스냅샷으로 저장 (비정규화)
✅ 상태 변경 이력을 이벤트 소싱으로 관리
✅ Kafka로 비동기 처리 (결제, 알림)
✅ 멱등성 키로 중복 방지
✅ Saga 패턴으로 분산 트랜잭션 관리
✅ 동적 필드를 metadata에 추가

### 10.2 DON'T
❌ Product 참조만 저장 (조인 필요)
❌ 동기식 결제 처리 (타임아웃 위험)
❌ 멱등성 검증 없이 주문 생성
❌ 보상 트랜잭션 없이 실패 처리
❌ 모든 이벤트를 무한정 저장