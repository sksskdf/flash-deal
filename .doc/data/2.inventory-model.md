# Inventory 도메인 모델 상세

## 1. 설계 철학

### Redis + MongoDB 하이브리드 전략
- **Redis**: 원자적 재고 감소 (DECR), 초고속 읽기/쓰기
- **MongoDB**: 재고 메타데이터, 이력, 백업, 분석

### 핵심 원칙
1. **Single Source of Truth**: Redis가 재고의 실시간 진실
2. **Eventually Consistent**: MongoDB는 비동기 동기화
3. **Atomic Operations**: 과판매 절대 방지
4. **Fault Tolerance**: Redis 장애 시 MongoDB fallback



## 2. MongoDB 스키마

### 2.1 Inventory 컬렉션
```javascript
{
  _id: ObjectId("65a1b2c3d4e5f6789abcdef0"),
  productId: ObjectId("..."),  // Product 참조
  
  // === 재고 수량 (Redis와 동기화) ===
  stock: {
    total: 1000,           // 총 재고 (초기값)
    reserved: 47,          // 예약된 재고 (pending orders)
    available: 953,        // 가용 재고 (total - reserved)
    sold: 0                // 판매 완료 수량
  },
  
  // === UI 표시용 레벨 ===
  level: "high",  // high (≥50%) | mid (20-50%) | low (<20%)
  
  // === Redis 연동 정보 ===
  redis: {
    key: "inventory:65a1b2c3d4e5f6789abcdef0",
    currentValue: 953,     // 현재 Redis 값
    lastSyncedAt: ISODate("2025-10-13T10:30:00Z"),
    syncVersion: 15        // 낙관적 락 버전
  },
  
  // === 재고 정책 ===
  policy: {
    // 안전 재고 (품절 임박 알림용)
    safetyStock: 50,
    
    // 재입고 정책
    restock: {
      enabled: true,
      threshold: 10,        // 이하로 떨어지면 재입고 요청
      quantity: 500,        // 재입고 수량
      supplier: "TechSupplier Co."
    },
    
    // 예약 시간 제한
    reservationTimeout: 600,  // 10분 (초)
    
    // 동적 필드 (향후 추가 가능)
    maxPurchasePerUser: 5,
    bulkDiscountThreshold: 10
  },
  
  // === 임계값 설정 (level 계산용) ===
  thresholds: {
    high: 0.5,    // 50% 이상
    mid: 0.2,     // 20% 이상
    low: 0.0      // 20% 미만
  },
  
  // === 이벤트 로그 (선택적, 분석용) ===
  events: [
    {
      type: "decrease",      // increase | decrease | reserve | release | sync
      amount: 1,
      before: 954,
      after: 953,
      reason: "order_confirmed",
      orderId: ObjectId("..."),
      timestamp: ISODate("2025-10-13T10:29:45Z"),
      
      // 동적 메타데이터
      metadata: {
        userId: "user123",
        source: "web",
        region: "Seoul"
      }
    },
    // ... 최근 100-1000개만 유지 (TTL 인덱스)
  ],
  
  // === 재고 조정 이력 (수동 조정) ===
  adjustments: [
    {
      type: "manual_increase",  // manual_increase | manual_decrease | system_correction
      amount: 100,
      reason: "재입고",
      adjustedBy: "admin@example.com",
      timestamp: ISODate("2025-10-13T09:00:00Z")
    }
  ],
  
  createdAt: ISODate("2025-10-01T00:00:00Z"),
  updatedAt: ISODate("2025-10-13T10:30:00Z")
}
```



## 3. Redis 데이터 구조

### 3.1 재고 카운터
```redis
# Key Pattern
inventory:{productId}

# Type: String (숫자로 사용)
# Value: 현재 가용 재고 수량
GET inventory:65a1b2c3d4e5f6789abcdef0
=> "953"

# 원자적 감소
DECR inventory:65a1b2c3d4e5f6789abcdef0
=> 952

# 조건부 감소 (Lua Script)
EVAL """
  local stock = redis.call('GET', KEYS[1])
  if tonumber(stock) > 0 then
    return redis.call('DECR', KEYS[1])
  else
    return -1
  end
""" 1 inventory:65a1b2c3d4e5f6789abcdef0
```

### 3.2 예약 관리 (선택적)
```redis
# 임시 예약 (10분 타임아웃)
# Key: inventory:reserved:{orderId}
SETEX inventory:reserved:order123 600 1

# 예약 수량 집계 (Sorted Set)
# Key: inventory:reservations:{productId}
# Score: 만료 시각 (timestamp)
# Member: orderId
ZADD inventory:reservations:65a1b2c3d4e5f6789abcdef0 1697184545 order123

# 만료된 예약 정리
ZREMRANGEBYSCORE inventory:reservations:65a1b2c3d4e5f6789abcdef0 0 {currentTimestamp}
```

### 3.3 분산 락 (동시성 제어)
```redis
# Key: inventory:lock:{productId}
# Value: 락 소유자 ID (UUID)
# TTL: 10초

# 락 획득 (NX: Not eXists, EX: 초 단위 TTL)
SET inventory:lock:65a1b2c3d4e5f6789abcdef0 uuid-12345 NX EX 10
=> OK (성공) 또는 nil (실패)

# 락 해제 (소유자 확인 후)
EVAL """
  if redis.call('GET', KEYS[1]) == ARGV[1] then
    return redis.call('DEL', KEYS[1])
  else
    return 0
  end
""" 1 inventory:lock:65a1b2c3d4e5f6789abcdef0 uuid-12345
```



## 4. 재고 감소 플로우

### 4.1 기본 플로우 (낙관적)
```
1. 클라이언트: 주문 요청
   └→ GraphQL Mutation: createOrder(productId, quantity)

2. 서버: Redis 재고 확인 및 감소
   ├→ GET inventory:{productId}
   │  └→ if stock >= quantity
   │     ├→ DECRBY inventory:{productId} {quantity}
   │     └→ 성공 → 단계 3
   │  └→ else
   │     └→ 실패 → "품절" 응답

3. 주문 생성 및 예약
   ├→ MongoDB: Order 생성 (status: pending)
   ├→ Redis: 예약 기록
   │  └→ ZADD inventory:reservations:{productId} {expiry} {orderId}
   └→ Kafka: OrderCreated 이벤트 발행

4. 비동기 처리 (Kafka Consumer)
   ├→ 결제 처리
   ├→ 성공 → Order.status = confirmed
   │  └→ MongoDB: Inventory.sold += quantity
   └→ 실패 → 재고 복구
      ├→ INCRBY inventory:{productId} {quantity}
      └→ ZREM inventory:reservations:{productId} {orderId}
```

### 4.2 분산 락 플로우 (비관적)
```
1. 락 획득 시도
   └→ SET inventory:lock:{productId} {uuid} NX EX 10
      ├→ 성공 → 단계 2
      └→ 실패 → 재시도 (최대 3회) 또는 에러

2. 재고 확인 및 감소 (락 보호)
   └→ GET inventory:{productId}
      └→ if stock >= quantity
         └→ DECRBY inventory:{productId} {quantity}

3. 주문 생성 (동일)

4. 락 해제
   └→ DEL inventory:lock:{productId} (소유자 확인)
```

### 4.3 Lua 스크립트 (원자적)
```lua
-- check_and_decrease.lua
local key = KEYS[1]
local quantity = tonumber(ARGV[1])
local orderId = ARGV[2]

local stock = tonumber(redis.call('GET', key))

if stock == nil then
  return {err = 'INVENTORY_NOT_FOUND'}
end

if stock < quantity then
  return {err = 'INSUFFICIENT_STOCK', current = stock}
end

-- 재고 감소
local newStock = redis.call('DECRBY', key, quantity)

-- 예약 기록 (선택)
local reservationKey = 'inventory:reservations:' .. string.match(key, 'inventory:(.+)')
local expiry = redis.call('TIME')[1] + 600  -- 10분 후
redis.call('ZADD', reservationKey, expiry, orderId)

return {ok = true, stock = newStock}
```



## 5. Redis-MongoDB 동기화

### 5.1 동기화 전략

#### Option 1: Event-Driven (추천)
```javascript
// Kafka Topic: inventory.sync
{
  productId: "65a1b2c3d4e5f6789abcdef0",
  action: "decrease",
  amount: 1,
  redisValue: 952,
  timestamp: "2025-10-13T10:30:00Z"
}

// Consumer
async function syncInventory(event) {
  await db.inventory.updateOne(
    { productId: event.productId },
    {
      $set: {
        'redis.currentValue': event.redisValue,
        'redis.lastSyncedAt': new Date(),
        'stock.available': event.redisValue
      },
      $inc: {
        'redis.syncVersion': 1
      }
    }
  );
  
  // 레벨 재계산
  await updateInventoryLevel(event.productId);
}
```

#### Option 2: Scheduled Job
```javascript
// 매 5분마다 실행
async function syncAllInventories() {
  const inventories = await db.inventory.find({ active: true });
  
  for (const inv of inventories) {
    const redisValue = await redis.get(inv.redis.key);
    
    if (redisValue !== inv.redis.currentValue) {
      await db.inventory.updateOne(
        { _id: inv._id },
        {
          $set: {
            'redis.currentValue': parseInt(redisValue),
            'redis.lastSyncedAt': new Date(),
            'stock.available': parseInt(redisValue)
          },
          $inc: { 'redis.syncVersion': 1 }
        }
      );
    }
  }
}
```

#### Option 3: CDC (Change Data Capture)
```javascript
// Redis Keyspace Notifications 활용
redis.config('SET', 'notify-keyspace-events', 'KEA');

// Subscribe to inventory key changes
redis.psubscribe('__keyspace@0__:inventory:*', (channel, message) => {
  const productId = channel.split(':')[1];
  
  if (message === 'set' || message === 'del' || message === 'incrby' || message === 'decrby') {
    // 비동기 동기화
    syncToMongoDB(productId);
  }
});
```

### 5.2 동기화 충돌 해결

#### 낙관적 락 (Optimistic Locking)
```javascript
async function syncWithVersion(productId, redisValue) {
  const inventory = await db.inventory.findOne({ productId });
  
  const result = await db.inventory.updateOne(
    {
      productId,
      'redis.syncVersion': inventory.redis.syncVersion  // 버전 체크
    },
    {
      $set: {
        'redis.currentValue': redisValue,
        'redis.lastSyncedAt': new Date()
      },
      $inc: {
        'redis.syncVersion': 1
      }
    }
  );
  
  if (result.modifiedCount === 0) {
    // 버전 충돌 → 재시도
    console.warn('Sync version conflict, retrying...');
    return syncWithVersion(productId, redisValue);
  }
}
```



## 6. 재고 레벨 계산

### 6.1 레벨 로직
```javascript
function calculateInventoryLevel(inventory) {
  const total = inventory.stock.total;
  const available = inventory.stock.available;
  const ratio = available / total;
  
  const { high, mid, low } = inventory.thresholds;
  
  if (ratio >= high) return 'high';
  if (ratio >= mid) return 'mid';
  return 'low';
}

// 레벨 업데이트 (비동기)
async function updateInventoryLevel(productId) {
  const inventory = await db.inventory.findOne({ productId });
  const level = calculateInventoryLevel(inventory);
  
  if (inventory.level !== level) {
    await db.inventory.updateOne(
      { productId },
      { $set: { level } }
    );
    
    // 레벨 변경 이벤트 발행
    if (level === 'low') {
      await kafka.publish('inventory.alert', {
        productId,
        level: 'low',
        available: inventory.stock.available,
        alertType: 'LOW_STOCK'
      });
    }
  }
}
```



## 7. 장애 복구 시나리오

### 7.1 Redis 장애
```javascript
async function handleRedisFailure(productId, quantity) {
  console.error('Redis failure detected');
  
  // Fallback: MongoDB로 재고 관리 (성능 저하)
  const session = await db.startSession();
  
  try {
    await session.withTransaction(async () => {
      const inventory = await db.inventory.findOne(
        { productId },
        { session }
      );
      
      if (inventory.stock.available < quantity) {
        throw new Error('INSUFFICIENT_STOCK');
      }
      
      await db.inventory.updateOne(
        { productId },
        {
          $inc: {
            'stock.available': -quantity,
            'stock.reserved': quantity
          }
        },
        { session }
      );
    });
    
    return { success: true };
  } catch (error) {
    return { success: false, error };
  } finally {
    await session.endSession();
  }
}
```

### 7.2 MongoDB 장애
```javascript
// Redis는 계속 동작 (재고 감소)
// MongoDB 복구 후 재동기화

async function reconcileAfterMongoDBFailure() {
  const redisKeys = await redis.keys('inventory:*');
  
  for (const key of redisKeys) {
    const productId = key.split(':')[1];
    const redisValue = await redis.get(key);
    
    // MongoDB 값과 비교
    const inventory = await db.inventory.findOne({ productId });
    
    if (!inventory) {
      console.warn(`Inventory not found for ${productId}`);
      continue;
    }
    
    const diff = redisValue - inventory.redis.currentValue;
    
    if (diff !== 0) {
      // 차이만큼 조정
      await db.inventory.updateOne(
        { productId },
        {
          $inc: {
            'stock.sold': -diff,  // Redis가 감소했으므로 sold 증가
            'stock.available': diff
          },
          $set: {
            'redis.currentValue': parseInt(redisValue),
            'redis.lastSyncedAt': new Date()
          }
        }
      );
      
      console.log(`Reconciled ${productId}: diff=${diff}`);
    }
  }
}
```

### 7.3 동기화 불일치 감지
```javascript
// Health Check
async function checkInventoryConsistency() {
  const inventories = await db.inventory.find({}).limit(100);
  const inconsistencies = [];
  
  for (const inv of inventories) {
    const redisValue = await redis.get(inv.redis.key);
    
    if (redisValue === null) {
      inconsistencies.push({
        productId: inv.productId,
        issue: 'REDIS_KEY_MISSING',
        mongo: inv.redis.currentValue,
        redis: null
      });
      continue;
    }
    
    const diff = Math.abs(parseInt(redisValue) - inv.redis.currentValue);
    
    if (diff > 10) {  // 10개 이상 차이
      inconsistencies.push({
        productId: inv.productId,
        issue: 'LARGE_DISCREPANCY',
        mongo: inv.redis.currentValue,
        redis: parseInt(redisValue),
        diff
      });
    }
  }
  
  if (inconsistencies.length > 0) {
    // 알림 발송
    await sendAlert('inventory.inconsistency', inconsistencies);
  }
  
  return inconsistencies;
}
```



## 8. 이벤트 로그 관리

### 8.1 TTL 인덱스
```javascript
// events 배열이 너무 커지지 않도록
db.inventory.createIndex(
  { "events.timestamp": 1 },
  { expireAfterSeconds: 2592000 }  // 30일 후 삭제
)

// 또는 Capped Array (최대 크기 제한)
db.inventory.updateOne(
  { productId },
  {
    $push: {
      events: {
        $each: [newEvent],
        $slice: -1000  // 최근 1000개만 유지
      }
    }
  }
)
```

### 8.2 별도 컬렉션으로 분리 (대용량)
```javascript
// inventory_events 컬렉션 (시계열 데이터)
{
  _id: ObjectId("..."),
  productId: ObjectId("..."),
  type: "decrease",
  amount: 1,
  before: 954,
  after: 953,
  orderId: ObjectId("..."),
  timestamp: ISODate("2025-10-13T10:29:45Z"),
  
  metadata: {
    userId: "user123",
    source: "web"
  }
}

// 시계열 컬렉션 (MongoDB 5.0+)
db.createCollection("inventory_events", {
  timeseries: {
    timeField: "timestamp",
    metaField: "productId",
    granularity: "seconds"
  }
})
```



## 9. 인덱스 전략

```javascript
// Inventory 컬렉션
db.inventory.createIndex({ productId: 1 }, { unique: true })
db.inventory.createIndex({ 'redis.key': 1 })
db.inventory.createIndex({ level: 1 })
db.inventory.createIndex({ 'stock.available': 1 })

// Events (별도 컬렉션인 경우)
db.inventory_events.createIndex({ productId: 1, timestamp: -1 })
db.inventory_events.createIndex({ type: 1, timestamp: -1 })
```



## 10. GraphQL 통합

### 10.1 쿼리
```graphql
type Inventory {
  id: ID!
  productId: ID!
  stock: StockInfo!
  level: InventoryLevel!
  redis: RedisInfo
  policy: InventoryPolicy
}

type StockInfo {
  total: Int!
  reserved: Int!
  available: Int!
  sold: Int!
}

enum InventoryLevel {
  HIGH
  MID
  LOW
}

type Query {
  inventory(productId: ID!): Inventory
  inventoryLevel(productId: ID!): InventoryLevel
}
```

### 10.2 Mutation
```graphql
type Mutation {
  # 재고 수동 조정 (관리자)
  adjustInventory(
    productId: ID!
    amount: Int!
    reason: String!
  ): Inventory
  
  # Redis 동기화 강제 실행
  syncInventory(productId: ID!): Inventory
}
```



## 11. Best Practices

### 11.1 DO
✅ Redis를 재고의 Single Source of Truth로 사용
✅ MongoDB는 메타데이터와 분석용으로 활용
✅ 원자적 연산 사용 (DECR, Lua Script)
✅ 분산 락은 필요시에만 (성능 고려)
✅ 동기화는 비동기로 처리
✅ 불일치 감지 및 자동 복구 메커니즘 구축

### 11.2 DON'T
❌ MongoDB를 실시간 재고 관리에 사용하지 말 것
❌ Redis 없이 MongoDB만으로 재고 관리 ❌
❌ 동기 동기화 (성능 저하)
❌ 너무 빈번한 동기화 (1초 이내)
❌ 이벤트 로그 무제한 저장 (디스크 고갈)