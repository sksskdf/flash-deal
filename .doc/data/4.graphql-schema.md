# GraphQL 스키마 설계

## 1. 설계 원칙

### API 설계 철학
- **Product-Centric**: 상품 중심 API (Flash Deal 특성)
- **Performance First**: DataLoader로 N+1 방지
- **Flexible Queries**: 클라이언트가 필요한 데이터만 요청
- **Real-time Ready**: Subscription으로 실시간 업데이트

### 핵심 고려사항
1. **Pagination**: Cursor-based (무한 스크롤)
2. **Filtering**: 복합 필터 지원
3. **Caching**: Redis + DataLoader
4. **Error Handling**: 명확한 에러 타입

## 2. 전체 스키마

### 2.1 스칼라 타입
```graphql
scalar DateTime
scalar JSON
scalar Upload
```

### 2.2 Product (상품)
```graphql
# 딜 타입 (다형성)
enum DealType {
  FLASH      # 플래시 딜
  TIME       # 시간대별 가격
  GROUP      # 그룹바이
}

# 딜 상태
enum DealStatus {
  UPCOMING   # 시작 전
  ACTIVE     # 진행 중
  SOLDOUT    # 품절
  ENDED      # 종료
}

# 재고 레벨
enum InventoryLevel {
  HIGH       # 충분
  MID        # 보통
  LOW        # 품절 임박
}

# 상품 기본 정보
type Product {
  id: ID!
  dealType: DealType!
  
  # 기본 정보
  title: String!
  subtitle: String
  description: String!
  category: String!
  images: [String!]!
  
  # 가격
  price: PriceInfo!
  
  # 일정
  schedule: ScheduleInfo!
  
  # 상태
  status: DealStatus!
  
  # 재고 (resolver로 조회)
  inventory: Inventory
  
  # 동적 속성 (JSON)
  specs: JSON
  metadata: JSON
  
  # 타임스탬프
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PriceInfo {
  original: Float!
  sale: Float!
  currency: String!
  rate: Float!
}

type ScheduleInfo {
  startsAt: DateTime!
  endsAt: DateTime!
  timezone: String
}

# Time Deal 특화
type TimeDeal implements Product {
  # Product 필드들...
  priceSchedule: [PriceSlot!]!
}

type PriceSlot {
  timeRange: TimeRange!
  price: PriceInfo!
}

type TimeRange {
  start: String!  # "00:00"
  end: String!    # "12:00"
}

# Group Buy 특화
type GroupBuyDeal implements Product {
  # Product 필드들...
  groupBuy: GroupBuyInfo!
}

type GroupBuyInfo {
  minParticipants: Int!
  maxParticipants: Int
  currentParticipants: Int!
  discountTiers: [DiscountTier!]!
  currentTier: DiscountTier
}

type DiscountTier {
  threshold: Int!
  discountRate: Float!
  price: Float!
}
```

### 2.3 Inventory (재고)
```graphql
type Inventory {
  id: ID!
  productId: ID!
  
  # 재고 정보
  stock: StockInfo!
  level: InventoryLevel!
  
  # Redis 정보
  redis: RedisInfo
  
  # 정책
  policy: InventoryPolicy
}

type StockInfo {
  total: Int!
  reserved: Int!
  available: Int!
  sold: Int!
}

type RedisInfo {
  key: String!
  currentValue: Int!
  lastSyncedAt: DateTime!
  syncVersion: Int!
}

type InventoryPolicy {
  safetyStock: Int
  restock: RestockPolicy
  reservationTimeout: Int
  maxPurchasePerUser: Int
}

type RestockPolicy {
  enabled: Boolean!
  threshold: Int!
  quantity: Int!
  supplier: String
}
```

### 2.4 Order (주문)
```graphql
enum OrderStatus {
  PENDING
  PROCESSING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
  FAILED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

type Order {
  id: ID!
  orderNumber: String!
  
  # 사용자
  user: UserInfo!
  
  # 주문 상품
  items: [OrderItem!]!
  
  # 금액
  pricing: PricingInfo!
  
  # 배송
  shipping: ShippingInfo!
  
  # 결제
  payment: PaymentInfo!
  
  # 상태
  status: OrderStatus!
  statusHistory: [StatusChange!]!
  
  # 메타데이터
  metadata: JSON
  
  # 타임스탬프
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserInfo {
  id: String!
  email: String!
  name: String!
  phone: String
}

type OrderItem {
  productId: ID!
  dealType: DealType!
  
  # 스냅샷
  snapshot: OrderItemSnapshot!
  
  quantity: Int!
  unitPrice: Float!
  subtotal: Float!
  
  # 개별 상태
  status: String
  tracking: TrackingInfo
}

type OrderItemSnapshot {
  title: String!
  subtitle: String
  image: String!
  category: String!
  price: PriceInfo!
  specs: JSON
  selectedOptions: JSON
}

type PricingInfo {
  subtotal: Float!
  shipping: Float!
  tax: Float
  discount: Float
  total: Float!
  currency: String!
  breakdown: JSON
}

type ShippingInfo {
  method: String!
  recipient: RecipientInfo!
  address: AddressInfo!
  instructions: String
  preferredTime: String
}

type RecipientInfo {
  name: String!
  phone: String!
}

type AddressInfo {
  type: String
  street: String!
  street2: String
  city: String!
  state: String
  zipCode: String!
  country: String!
  coordinates: Coordinates
}

type Coordinates {
  lat: Float!
  lng: Float!
}

type PaymentInfo {
  method: String!
  card: CardInfo
  status: PaymentStatus!
  gateway: PaymentGatewayInfo
  refund: RefundInfo
}

type CardInfo {
  last4: String!
  brand: String!
  expiryMonth: Int!
  expiryYear: Int!
}

type PaymentGatewayInfo {
  provider: String!
  transactionId: String!
  receiptUrl: String
  chargedAt: DateTime
}

type RefundInfo {
  amount: Float
  reason: String
  refundedAt: DateTime
  transactionId: String
}

type StatusChange {
  from: String
  to: String!
  timestamp: DateTime!
  reason: String
  actor: String
  metadata: JSON
}

type TrackingInfo {
  carrier: String!
  trackingNumber: String!
  shippedAt: DateTime
  estimatedDelivery: DateTime
}
```



## 3. Query

### 3.1 Product Queries
```graphql
type Query {
  # 단일 상품 조회
  product(id: ID!): Product
  
  # 상품 목록
  products(
    filter: ProductFilter
    sort: ProductSort
    pagination: PaginationInput
  ): ProductConnection!
  
  # Featured 상품
  featuredProducts(limit: Int = 10): [Product!]!
  
  # 카테고리별
  productsByCategory(
    category: String!
    status: DealStatus
    limit: Int = 20
  ): [Product!]!
  
  # 검색
  searchProducts(
    query: String!
    filter: ProductFilter
    pagination: PaginationInput
  ): ProductConnection!
}

# 필터
input ProductFilter {
  status: DealStatus
  category: String
  dealType: DealType
  priceRange: PriceRangeInput
  inventoryLevel: InventoryLevel
}

input PriceRangeInput {
  min: Float
  max: Float
}

# 정렬
input ProductSort {
  field: ProductSortField!
  direction: SortDirection!
}

enum ProductSortField {
  CREATED_AT
  STARTS_AT
  ENDS_AT
  PRICE
  DISCOUNT_RATE
  POPULARITY
}

enum SortDirection {
  ASC
  DESC
}

# Pagination (Cursor-based)
input PaginationInput {
  first: Int
  after: String
  last: Int
  before: String
}

type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductEdge {
  cursor: String!
  node: Product!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
```

### 3.2 Inventory Queries
```graphql
type Query {
  # 재고 조회
  inventory(productId: ID!): Inventory
  
  # 재고 레벨만 조회 (빠른 응답)
  inventoryLevel(productId: ID!): InventoryLevel
  
  # 재고 가용성 체크
  checkAvailability(
    productId: ID!
    quantity: Int!
  ): AvailabilityResult!
}

type AvailabilityResult {
  available: Boolean!
  currentStock: Int!
  maxPurchasable: Int!
  message: String
}
```

### 3.3 Order Queries
```graphql
type Query {
  # 주문 조회
  order(id: ID!): Order
  orderByNumber(orderNumber: String!): Order
  
  # 내 주문 목록
  myOrders(
    status: OrderStatus
    pagination: PaginationInput
  ): OrderConnection!
  
  # 주문 상태 추적
  trackOrder(orderNumber: String!): OrderTrackingInfo!
}

type OrderConnection {
  edges: [OrderEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrderEdge {
  cursor: String!
  node: Order!
}

type OrderTrackingInfo {
  orderNumber: String!
  status: OrderStatus!
  items: [OrderItem!]!
  shipping: ShippingInfo
  tracking: [TrackingEvent!]
}

type TrackingEvent {
  status: String!
  location: String
  description: String!
  timestamp: DateTime!
}
```



## 4. Mutation

### 4.1 Order Mutations
```graphql
type Mutation {
  # 주문 생성
  createOrder(
    input: CreateOrderInput!
    idempotencyKey: String!
  ): CreateOrderResult!
  
  # 주문 취소
  cancelOrder(
    orderId: ID!
    reason: String
  ): Order!
  
  # 부분 취소
  cancelOrderItems(
    orderId: ID!
    items: [CancelItemInput!]!
    reason: String
  ): Order!
}

input CreateOrderInput {
  items: [OrderItemInput!]!
  shipping: ShippingInput!
  payment: PaymentInput!
  metadata: JSON
}

input OrderItemInput {
  productId: ID!
  quantity: Int!
  selectedOptions: JSON
}

input ShippingInput {
  method: String!
  recipient: RecipientInput!
  address: AddressInput!
  instructions: String
  preferredTime: String
}

input RecipientInput {
  name: String!
  phone: String!
}

input AddressInput {
  type: String
  street: String!
  street2: String
  city: String!
  state: String
  zipCode: String!
  country: String!
}

input PaymentInput {
  method: String!
  cardToken: String  # 토큰화된 카드 정보
  installment: InstallmentInput
}

input InstallmentInput {
  months: Int!
  interestRate: Float
}

input CancelItemInput {
  productId: ID!
  quantity: Int!
  reason: String
}

# 응답
type CreateOrderResult {
  order: Order
  isDuplicate: Boolean!
  errors: [OrderError!]
}

type OrderError {
  code: OrderErrorCode!
  message: String!
  field: String
  metadata: JSON
}

enum OrderErrorCode {
  INSUFFICIENT_STOCK
  INVALID_PRODUCT
  PAYMENT_FAILED
  INVALID_ADDRESS
  DUPLICATE_ORDER
  SYSTEM_ERROR
}
```

### 4.2 Inventory Mutations (관리자)
```graphql
type Mutation {
  # 재고 수동 조정
  adjustInventory(
    productId: ID!
    amount: Int!
    reason: String!
  ): Inventory!
  
  # Redis 동기화 강제 실행
  syncInventory(productId: ID!): Inventory!
  
  # 재고 정책 업데이트
  updateInventoryPolicy(
    productId: ID!
    policy: InventoryPolicyInput!
  ): Inventory!
}

input InventoryPolicyInput {
  safetyStock: Int
  restock: RestockPolicyInput
  reservationTimeout: Int
  maxPurchasePerUser: Int
}

input RestockPolicyInput {
  enabled: Boolean!
  threshold: Int!
  quantity: Int!
  supplier: String
}
```



## 5. Subscription (실시간)

```graphql
type Subscription {
  # 상품 상태 변경
  productStatusChanged(productId: ID!): ProductStatusUpdate!
  
  # 재고 변경
  inventoryChanged(productId: ID!): InventoryUpdate!
  
  # 주문 상태 변경
  orderStatusChanged(orderId: ID!): OrderStatusUpdate!
  
  # 딜 시작 알림
  dealStarting(minutes: Int = 5): DealStartNotification!
}

type ProductStatusUpdate {
  productId: ID!
  oldStatus: DealStatus!
  newStatus: DealStatus!
  timestamp: DateTime!
}

type InventoryUpdate {
  productId: ID!
  stock: StockInfo!
  level: InventoryLevel!
  timestamp: DateTime!
}

type OrderStatusUpdate {
  orderId: ID!
  orderNumber: String!
  oldStatus: OrderStatus!
  newStatus: OrderStatus!
  timestamp: DateTime!
}

type DealStartNotification {
  product: Product!
  startsAt: DateTime!
  minutesUntilStart: Int!
}
```



## 6. Resolver 구현 가이드

### 6.1 DataLoader (N+1 방지)
```javascript
// Inventory DataLoader
const inventoryLoader = new DataLoader(async (productIds) => {
  const inventories = await db.inventory.find({
    productId: { $in: productIds }
  });
  
  // productIds 순서대로 매칭
  return productIds.map(id =>
    inventories.find(inv => inv.productId.equals(id))
  );
});

// Resolver
const resolvers = {
  Product: {
    inventory: async (parent, args, { loaders }) => {
      return loaders.inventory.load(parent._id);
    }
  }
};
```

### 6.2 Redis 캐싱
```javascript
const resolvers = {
  Query: {
    product: async (parent, { id }, { redis, db }) => {
      // 캐시 확인
      const cached = await redis.get(`product:${id}`);
      if (cached) {
        return JSON.parse(cached);
      }
      
      // DB 조회
      const product = await db.products.findOne({ _id: id });
      
      // 캐시 저장 (5분)
      await redis.setex(
        `product:${id}`,
        300,
        JSON.stringify(product)
      );
      
      return product;
    }
  }
};
```

### 6.3 Cursor Pagination
```javascript
const resolvers = {
  Query: {
    products: async (parent, { filter, sort, pagination }, { db }) => {
      const { first, after, last, before } = pagination || {};
      
      // 쿼리 빌드
      let query = db.products.find(buildFilter(filter));
      
      if (sort) {
        query = query.sort({
          [sort.field]: sort.direction === 'ASC' ? 1 : -1
        });
      }
      
      // Cursor 디코딩
      if (after) {
        const cursor = decodeCursor(after);
        query = query.where('_id').gt(cursor);
      }
      
      // 한 개 더 조회 (hasNextPage 확인)
      const limit = first || 20;
      const results = await query.limit(limit + 1).toArray();
      
      const hasNextPage = results.length > limit;
      const edges = results.slice(0, limit).map(node => ({
        cursor: encodeCursor(node._id),
        node
      }));
      
      return {
        edges,
        pageInfo: {
          hasNextPage,
          hasPreviousPage: !!after,
          startCursor: edges[0]?.cursor,
          endCursor: edges[edges.length - 1]?.cursor
        },
        totalCount: await db.products.countDocuments(buildFilter(filter))
      };
    }
  }
};

function encodeCursor(id) {
  return Buffer.from(id.toString()).toString('base64');
}

function decodeCursor(cursor) {
  return Buffer.from(cursor, 'base64').toString('utf8');
}
```



## 7. Error Handling

### 7.1 에러 타입
```graphql
# Union 타입으로 성공/실패 구분
type CreateOrderResult {
  success: OrderSuccessResult
  error: OrderErrorResult
}

type OrderSuccessResult {
  order: Order!
  isDuplicate: Boolean!
}

type OrderErrorResult {
  code: OrderErrorCode!
  message: String!
  details: JSON
}
```

### 7.2 Resolver 구현
```javascript
const resolvers = {
  Mutation: {
    createOrder: async (parent, { input, idempotencyKey }, ctx) => {
      try {
        // 멱등성 체크
        const existing = await ctx.db.orders.findOne({ idempotencyKey });
        if (existing) {
          return {
            success: {
              order: existing,
              isDuplicate: true
            }
          };
        }
        
        // 재고 체크
        const available = await checkInventory(input.items);
        if (!available) {
          return {
            error: {
              code: 'INSUFFICIENT_STOCK',
              message: '재고가 부족합니다',
              details: { items: input.items }
            }
          };
        }
        
        // 주문 생성
        const order = await createOrderSaga(input, idempotencyKey);
        
        return {
          success: {
            order,
            isDuplicate: false
          }
        };
        
      } catch (error) {
        return {
          error: {
            code: 'SYSTEM_ERROR',
            message: error.message,
            details: { stack: error.stack }
          }
        };
      }
    }
  }
};
```



## 8. 성능 최적화

### 8.1 필드 레벨 캐싱
```javascript
const resolvers = {
  Product: {
    inventory: async (parent, args, { redis, loaders }) => {
      const key = `inventory:${parent._id}`;
      
      // Redis 먼저 체크
      const redisValue = await redis.get(key);
      if (redisValue !== null) {
        return {
          stock: {
            available: parseInt(redisValue)
          }
        };
      }
      
      // DataLoader로 조회
      return loaders.inventory.load(parent._id);
    }
  }
};
```

### 8.2 쿼리 복잡도 제한
```javascript
import { createComplexityLimitRule } from 'graphql-validation-complexity';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  validationRules: [
    createComplexityLimitRule(1000, {
      onCost: (cost) => console.log('Query cost:', cost)
    })
  ]
});
```

### 8.3 배치 쿼리
```graphql
# 단일 쿼리로 여러 데이터 조회
query DashboardData {
  featuredProducts(limit: 4) {
    id
    title
    price { sale }
    inventory { level }
  }
  
  myOrders(pagination: { first: 5 }) {
    edges {
      node {
        id
        status
        total
      }
    }
  }
}
```



## 9. 보안

### 9.1 인증/인가
```javascript
const resolvers = {
  Query: {
    myOrders: async (parent, args, { user, db }) => {
      // 인증 확인
      if (!user) {
        throw new AuthenticationError('로그인이 필요합니다');
      }
      
      return db.orders.find({ 'user.id': user.id });
    }
  },
  
  Mutation: {
    adjustInventory: async (parent, args, { user }) => {
      // 관리자 권한 확인
      if (!user?.roles?.includes('admin')) {
        throw new ForbiddenError('관리자 권한이 필요합니다');
      }
      
      // ...
    }
  }
};
```

### 9.2 Rate Limiting
```javascript
import { createRateLimitDirective } from 'graphql-rate-limit-directive';

const typeDefs = gql`
  directive @rateLimit(
    limit: Int!
    duration: Int!
  ) on FIELD_DEFINITION
  
  type Mutation {
    createOrder(
      input: CreateOrderInput!
      idempotencyKey: String!
    ): CreateOrderResult! @rateLimit(limit: 10, duration: 60)
  }
`;
```



## 10. Testing

### 10.1 Query 테스트
```javascript
describe('Product Queries', () => {
  it('should fetch product by id', async () => {
    const query = gql`
      query GetProduct($id: ID!) {
        product(id: $id) {
          id
          title
          price { sale }
        }
      }
    `;
    
    const result = await executeQuery(query, {
      id: 'product123'
    });
    
    expect(result.data.product).toBeDefined();
    expect(result.data.product.title).toBe('Test Product');
  });
});
```

### 10.2 Mutation 테스트
```javascript
describe('Order Mutations', () => {
  it('should create order with idempotency', async () => {
    const mutation = gql`
      mutation CreateOrder($input: CreateOrderInput!, $key: String!) {
        createOrder(input: $input, idempotencyKey: $key) {
          success {
            order { id }
            isDuplicate
          }
        }
      }
    `;
    
    const variables = {
      input: { /* ... */ },
      key: 'idem-test-123'
    };
    
    // 첫 번째 호출
    const result1 = await executeMutation(mutation, variables);
    expect(result1.data.createOrder.success.isDuplicate).toBe(false);
    
    // 두 번째 호출 (중복)
    const result2 = await executeMutation(mutation, variables);
    expect(result2.data.createOrder.success.isDuplicate).toBe(true);
  });
});
```