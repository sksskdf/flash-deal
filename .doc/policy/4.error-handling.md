# 에러 처리

## 에러 분류

### 1. 시스템 에러 (CRITICAL)
- 데이터베이스 연결 실패
- Redis/Kafka 장애
- 외부 API 중단
- **대응**: 즉시 (5분 이내)

### 2. 애플리케이션 에러 (HIGH)
- 주문/결제 처리 실패
- 재고 동기화 실패
- **대응**: 15분 이내

### 3. 비즈니스 에러 (MEDIUM)
- 재고 부족
- 결제 정보 오류
- **대응**: 1시간 이내

### 4. 사용자 에러 (LOW)
- 잘못된 입력
- 권한 부족
- **대응**: 실시간

## 핵심 에러 처리

### 1. 입력 검증
```javascript
function validateOrderInput(input) {
  const errors = [];
  
  if (!input.userId) {
    errors.push({ field: 'userId', message: '사용자 ID가 필요합니다' });
  }
  
  if (!input.items || input.items.length === 0) {
    errors.push({ field: 'items', message: '주문 상품이 필요합니다' });
  }
  
  return errors;
}
```

### 2. 재시도 메커니즘
```javascript
async function retryOperation(operation, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (attempt === maxRetries) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }
}
```

### 3. 서킷 브레이커
```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = 'CLOSED';
  }
  
  async execute(operation) {
    if (this.state === 'OPEN') {
      throw new Error('Circuit breaker is OPEN');
    }
    
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
}
```

## 에러 모니터링

### 1. 구조화된 로깅
```javascript
const errorLogger = {
  log(error, context = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: error.level || 'ERROR',
      message: error.message,
      code: error.code,
      context: {
        userId: context.userId,
        orderId: context.orderId,
        ...context
      }
    };
    
    if (error.level === 'CRITICAL') {
      this.sendAlert(logEntry);
    }
    
    console.error(JSON.stringify(logEntry));
  }
};
```

### 2. 알림 규칙
```javascript
const alertRules = {
  criticalErrors: { threshold: 1, window: 60000 },  // 1분 내 1건
  errorRate: { threshold: 0.05, window: 300000 }   // 5분 내 5%
};
```

## 에러 복구

### 1. 자동 복구
```javascript
// 재고 동기화 복구
async function recoverInventorySync(productId) {
  const redisValue = await redis.get(`inventory:${productId}`);
  const mongoDoc = await db.inventory.findOne({ productId });
  
  if (redisValue !== mongoDoc.redis.currentValue.toString()) {
    await db.inventory.updateOne(
      { productId },
      {
        $set: {
          'redis.currentValue': parseInt(redisValue),
          'stock.available': parseInt(redisValue)
        }
      }
    );
  }
}
```

### 2. 수동 복구
```javascript
class RecoveryManager {
  async recoverOrder(orderId, action) {
    switch (action) {
      case 'retry_payment':
        return await this.retryPayment(order);
      case 'release_inventory':
        return await this.releaseInventory(order);
      default:
        throw new Error(`Unknown action: ${action}`);
    }
  }
}
```

## 에러 처리 원칙

1. **실패는 빠르게** - 조기 검증, 명확한 메시지
2. **복구는 자동으로** - 재시도, 서킷 브레이커
3. **모니터링은 실시간으로** - 메트릭, 알림
4. **학습은 지속적으로** - 분석, 개선
