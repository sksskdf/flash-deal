# 에러 처리 정책

## 에러 분류 체계

### 1. 시스템 에러 (System Errors)
```
레벨: CRITICAL
영향도: 전체 시스템
예시:
- 데이터베이스 연결 실패
- Redis 서버 다운
- Kafka 브로커 장애
- 외부 API 서비스 중단

대응 시간: 즉시 (5분 이내)
복구 시간: 30분 이내
```

### 2. 애플리케이션 에러 (Application Errors)
```
레벨: HIGH
영향도: 특정 기능
예시:
- 주문 처리 실패
- 결제 처리 오류
- 재고 동기화 실패
- 이메일 발송 실패

대응 시간: 15분 이내
복구 시간: 1시간 이내
```

### 3. 비즈니스 에러 (Business Errors)
```
레벨: MEDIUM
영향도: 사용자 경험
예시:
- 재고 부족
- 결제 정보 오류
- 배송지 정보 오류
- 쿠폰 사용 불가

대응 시간: 1시간 이내
복구 시간: 4시간 이내
```

### 4. 사용자 에러 (User Errors)
```
레벨: LOW
영향도: 개별 사용자
예시:
- 잘못된 입력
- 권한 부족
- 세션 만료
- 네트워크 오류

대응 시간: 실시간
복구 시간: 즉시
```

## 에러 처리 전략

### 1. 예방적 에러 처리
```javascript
// 입력 검증
function validateOrderInput(input) {
  const errors = [];
  
  if (!input.userId) {
    errors.push({ field: 'userId', message: '사용자 ID가 필요합니다' });
  }
  
  if (!input.items || input.items.length === 0) {
    errors.push({ field: 'items', message: '주문 상품이 필요합니다' });
  }
  
  if (input.items) {
    input.items.forEach((item, index) => {
      if (!item.productId) {
        errors.push({ 
          field: `items[${index}].productId`, 
          message: '상품 ID가 필요합니다' 
        });
      }
      if (!item.quantity || item.quantity <= 0) {
        errors.push({ 
          field: `items[${index}].quantity`, 
          message: '수량은 1 이상이어야 합니다' 
        });
      }
    });
  }
  
  return errors;
}

// 재고 확인
async function checkInventory(productId, quantity) {
  try {
    const stock = await redis.get(`inventory:${productId}`);
    if (!stock || parseInt(stock) < quantity) {
      throw new BusinessError('INSUFFICIENT_STOCK', {
        productId,
        requested: quantity,
        available: parseInt(stock) || 0
      });
    }
    return true;
  } catch (error) {
    if (error instanceof BusinessError) {
      throw error;
    }
    throw new SystemError('INVENTORY_CHECK_FAILED', {
      productId,
      originalError: error.message
    });
  }
}
```

### 2. 방어적 프로그래밍
```javascript
// 안전한 데이터베이스 접근
async function safeDatabaseOperation(operation, fallback = null) {
  try {
    return await operation();
  } catch (error) {
    console.error('Database operation failed:', error);
    
    // 재시도 로직
    if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      try {
        return await operation();
      } catch (retryError) {
        console.error('Database retry failed:', retryError);
        return fallback;
      }
    }
    
    return fallback;
  }
}

// 타임아웃 처리
async function withTimeout(promise, timeoutMs = 5000) {
  const timeout = new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Operation timeout')), timeoutMs)
  );
  
  return Promise.race([promise, timeout]);
}
```

### 3. 회복 가능한 에러 처리
```javascript
// 재시도 메커니즘
async function retryOperation(operation, maxRetries = 3, delay = 1000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      console.warn(`Attempt ${attempt} failed:`, error.message);
      
      if (attempt === maxRetries) {
        throw error;
      }
      
      // 지수 백오프
      const backoffDelay = delay * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, backoffDelay));
    }
  }
}

// 서킷 브레이커 패턴
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }
  
  async execute(operation) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}
```

## 에러 로깅 및 모니터링

### 1. 구조화된 로깅
```javascript
// 에러 로그 구조
const errorLogger = {
  log(error, context = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: error.level || 'ERROR',
      message: error.message,
      stack: error.stack,
      code: error.code,
      context: {
        userId: context.userId,
        orderId: context.orderId,
        productId: context.productId,
        sessionId: context.sessionId,
        requestId: context.requestId,
        ...context
      },
      metadata: {
        userAgent: context.userAgent,
        ip: context.ip,
        url: context.url,
        method: context.method
      }
    };
    
    // 로그 레벨별 처리
    if (error.level === 'CRITICAL') {
      this.sendAlert(logEntry);
    }
    
    console.error(JSON.stringify(logEntry));
  },
  
  sendAlert(logEntry) {
    // Slack, 이메일, SMS 등으로 알림
    console.log('ALERT:', logEntry);
  }
};

// 사용 예시
try {
  await processOrder(orderData);
} catch (error) {
  errorLogger.log(error, {
    userId: orderData.userId,
    orderId: orderData.orderId,
    operation: 'processOrder'
  });
  throw error;
}
```

### 2. 실시간 모니터링
```javascript
// 에러 메트릭 수집
class ErrorMetrics {
  constructor() {
    this.counts = new Map();
    this.rates = new Map();
    this.lastReset = Date.now();
  }
  
  recordError(errorType, severity) {
    const key = `${errorType}:${severity}`;
    this.counts.set(key, (this.counts.get(key) || 0) + 1);
    
    // 5분마다 메트릭 리셋
    if (Date.now() - this.lastReset > 300000) {
      this.calculateRates();
      this.reset();
    }
  }
  
  calculateRates() {
    const totalErrors = Array.from(this.counts.values())
      .reduce((sum, count) => sum + count, 0);
    
    for (const [key, count] of this.counts) {
      this.rates.set(key, count / totalErrors);
    }
  }
  
  getCriticalErrors() {
    return Array.from(this.counts.entries())
      .filter(([key]) => key.includes('CRITICAL'))
      .map(([key, count]) => ({ error: key, count }));
  }
}

// 사용 예시
const errorMetrics = new ErrorMetrics();

try {
  await criticalOperation();
} catch (error) {
  errorMetrics.recordError('CRITICAL_OPERATION_FAILED', 'CRITICAL');
  throw error;
}
```

### 3. 알림 시스템
```javascript
// 알림 규칙 정의
const alertRules = {
  errorRate: {
    threshold: 0.05, // 5% 이상
    window: 300000,  // 5분
    action: 'immediate'
  },
  criticalErrors: {
    threshold: 1,     // 1건 이상
    window: 60000,   // 1분
    action: 'immediate'
  },
  systemHealth: {
    threshold: 0.95,  // 95% 이하
    window: 1800000, // 30분
    action: 'scheduled'
  }
};

// 알림 발송
class AlertManager {
  async sendAlert(alert) {
    const channels = this.getAlertChannels(alert.severity);
    
    for (const channel of channels) {
      try {
        await this.sendToChannel(channel, alert);
      } catch (error) {
        console.error(`Failed to send alert via ${channel}:`, error);
      }
    }
  }
  
  getAlertChannels(severity) {
    const channelMap = {
      CRITICAL: ['slack', 'email', 'sms'],
      HIGH: ['slack', 'email'],
      MEDIUM: ['email'],
      LOW: ['slack']
    };
    
    return channelMap[severity] || ['slack'];
  }
}
```

## 에러 복구 전략

### 1. 자동 복구
```javascript
// 재고 동기화 실패 복구
async function recoverInventorySync(productId) {
  try {
    // Redis 값 확인
    const redisValue = await redis.get(`inventory:${productId}`);
    
    // MongoDB 값 확인
    const mongoDoc = await db.inventory.findOne({ productId });
    
    if (redisValue !== mongoDoc.redis.currentValue.toString()) {
      console.log(`Inventory sync mismatch for ${productId}`);
      
      // Redis 값을 기준으로 MongoDB 동기화
      await db.inventory.updateOne(
        { productId },
        {
          $set: {
            'redis.currentValue': parseInt(redisValue),
            'redis.lastSyncedAt': new Date(),
            'stock.available': parseInt(redisValue)
          },
          $inc: { 'redis.syncVersion': 1 }
        }
      );
      
      console.log(`Inventory sync recovered for ${productId}`);
    }
  } catch (error) {
    console.error(`Failed to recover inventory sync for ${productId}:`, error);
    throw error;
  }
}

// 결제 실패 복구
async function recoverPaymentFailure(orderId) {
  try {
    const order = await db.orders.findOne({ _id: orderId });
    
    if (order.status === 'processing') {
      // 결제 상태 확인
      const paymentStatus = await checkPaymentStatus(order.paymentId);
      
      if (paymentStatus === 'completed') {
        // 결제는 성공했지만 주문 상태가 업데이트되지 않음
        await updateOrderStatus(orderId, 'confirmed', 'Payment recovery');
        console.log(`Payment recovery completed for order ${orderId}`);
      } else {
        // 결제 실패 확인
        await updateOrderStatus(orderId, 'failed', 'Payment failed');
        await releaseInventory(order.items);
        console.log(`Payment failure confirmed for order ${orderId}`);
      }
    }
  } catch (error) {
    console.error(`Failed to recover payment for order ${orderId}:`, error);
    throw error;
  }
}
```

### 2. 수동 복구 절차
```javascript
// 관리자 복구 도구
class RecoveryManager {
  async recoverOrder(orderId, action) {
    const order = await db.orders.findOne({ _id: orderId });
    
    switch (action) {
      case 'retry_payment':
        return await this.retryPayment(order);
      case 'release_inventory':
        return await this.releaseInventory(order);
      case 'cancel_order':
        return await this.cancelOrder(order);
      case 'force_confirm':
        return await this.forceConfirm(order);
      default:
        throw new Error(`Unknown recovery action: ${action}`);
    }
  }
  
  async retryPayment(order) {
    // 결제 재시도
    const paymentResult = await processPayment(order.payment);
    
    if (paymentResult.success) {
      await updateOrderStatus(order._id, 'confirmed', 'Payment retry successful');
      return { success: true, message: 'Payment retry successful' };
    } else {
      return { success: false, message: 'Payment retry failed', error: paymentResult.error };
    }
  }
  
  async releaseInventory(order) {
    // 재고 해제
    for (const item of order.items) {
      await redis.incrby(`inventory:${item.productId}`, item.quantity);
    }
    
    await updateOrderStatus(order._id, 'cancelled', 'Inventory released');
    return { success: true, message: 'Inventory released' };
  }
}
```

### 3. 데이터 복구
```javascript
// 백업에서 복구
async function restoreFromBackup(collection, documentId, backupDate) {
  try {
    // 백업 데이터 조회
    const backup = await db.backups.findOne({
      collection,
      documentId,
      createdAt: { $lte: new Date(backupDate) }
    });
    
    if (!backup) {
      throw new Error('Backup not found');
    }
    
    // 현재 문서 백업
    const currentDoc = await db[collection].findOne({ _id: documentId });
    await db.backups.insertOne({
      collection,
      documentId,
      data: currentDoc,
      createdAt: new Date(),
      type: 'pre_restore'
    });
    
    // 백업 데이터로 복원
    await db[collection].replaceOne(
      { _id: documentId },
      backup.data
    );
    
    console.log(`Document ${documentId} restored from backup`);
    return { success: true };
  } catch (error) {
    console.error(`Failed to restore document ${documentId}:`, error);
    throw error;
  }
}
```

## 에러 대응 절차

### 1. 에러 감지 및 분류
```javascript
// 에러 분류기
class ErrorClassifier {
  classify(error, context) {
    const classification = {
      severity: this.getSeverity(error),
      category: this.getCategory(error),
      impact: this.getImpact(error, context),
      urgency: this.getUrgency(error, context)
    };
    
    return classification;
  }
  
  getSeverity(error) {
    if (error instanceof SystemError) return 'CRITICAL';
    if (error instanceof ApplicationError) return 'HIGH';
    if (error instanceof BusinessError) return 'MEDIUM';
    return 'LOW';
  }
  
  getCategory(error) {
    if (error.code?.includes('DATABASE')) return 'DATABASE';
    if (error.code?.includes('PAYMENT')) return 'PAYMENT';
    if (error.code?.includes('INVENTORY')) return 'INVENTORY';
    if (error.code?.includes('NETWORK')) return 'NETWORK';
    return 'GENERAL';
  }
  
  getImpact(error, context) {
    if (context.affectsAllUsers) return 'SYSTEM_WIDE';
    if (context.affectsMultipleUsers) return 'MULTIPLE_USERS';
    if (context.affectsSingleUser) return 'SINGLE_USER';
    return 'UNKNOWN';
  }
}
```

### 2. 에러 대응 워크플로우
```javascript
// 에러 대응 프로세스
class ErrorResponseWorkflow {
  async handleError(error, context) {
    const classification = this.classifier.classify(error, context);
    
    // 1. 즉시 대응
    await this.immediateResponse(error, classification);
    
    // 2. 알림 발송
    await this.sendNotifications(error, classification);
    
    // 3. 복구 시도
    await this.attemptRecovery(error, classification);
    
    // 4. 모니터링 설정
    await this.setupMonitoring(error, classification);
    
    // 5. 사후 분석 스케줄링
    await this.schedulePostAnalysis(error, classification);
  }
  
  async immediateResponse(error, classification) {
    switch (classification.severity) {
      case 'CRITICAL':
        await this.activateEmergencyProtocol();
        break;
      case 'HIGH':
        await this.activateHighPriorityProtocol();
        break;
      case 'MEDIUM':
        await this.activateStandardProtocol();
        break;
      case 'LOW':
        await this.logAndContinue();
        break;
    }
  }
  
  async activateEmergencyProtocol() {
    // 긴급 프로토콜 활성화
    console.log('EMERGENCY PROTOCOL ACTIVATED');
    
    // 1. 시스템 상태 확인
    await this.checkSystemHealth();
    
    // 2. 백업 시스템 활성화
    await this.activateBackupSystems();
    
    // 3. 관리자 알림
    await this.notifyAdministrators();
    
    // 4. 사용자 알림
    await this.notifyUsers();
  }
}
```

### 3. 사후 분석 및 개선
```javascript
// 에러 분석 및 개선
class ErrorAnalysis {
  async analyzeError(error, context, resolution) {
    const analysis = {
      errorId: this.generateErrorId(),
      timestamp: new Date(),
      error: {
        message: error.message,
        stack: error.stack,
        code: error.code
      },
      context,
      resolution,
      impact: this.calculateImpact(error, context),
      rootCause: await this.identifyRootCause(error, context),
      improvements: await this.suggestImprovements(error, context)
    };
    
    // 분석 결과 저장
    await db.errorAnalysis.insertOne(analysis);
    
    // 개선 사항 추적
    await this.trackImprovements(analysis.improvements);
    
    return analysis;
  }
  
  async identifyRootCause(error, context) {
    // 근본 원인 분석
    const causes = [];
    
    if (error.code === 'DATABASE_CONNECTION_FAILED') {
      causes.push('Database server overload');
      causes.push('Network connectivity issues');
      causes.push('Resource exhaustion');
    }
    
    if (error.code === 'PAYMENT_PROCESSING_FAILED') {
      causes.push('Payment gateway timeout');
      causes.push('Invalid payment data');
      causes.push('External service unavailability');
    }
    
    return causes;
  }
  
  async suggestImprovements(error, context) {
    const improvements = [];
    
    // 예방적 개선사항
    if (error.code === 'DATABASE_CONNECTION_FAILED') {
      improvements.push('Implement connection pooling');
      improvements.push('Add database health checks');
      improvements.push('Implement circuit breaker pattern');
    }
    
    // 모니터링 개선
    improvements.push('Add real-time monitoring');
    improvements.push('Implement predictive alerts');
    improvements.push('Enhance logging granularity');
    
    return improvements;
  }
}
```

## 에러 처리 모범 사례

### 1. 에러 처리 원칙
```
1. 실패는 빠르게 (Fail Fast)
   - 조기 검증
   - 명확한 에러 메시지
   - 적절한 에러 코드

2. 복구는 자동으로 (Automatic Recovery)
   - 재시도 메커니즘
   - 회로 차단기
   - 백업 시스템

3. 모니터링은 실시간으로 (Real-time Monitoring)
   - 에러 메트릭
   - 알림 시스템
   - 대시보드

4. 학습은 지속적으로 (Continuous Learning)
   - 에러 분석
   - 개선 사항 도출
   - 예방 조치
```

### 2. 에러 처리 체크리스트
```
□ 에러 분류 체계 정의
□ 로깅 표준 수립
□ 모니터링 시스템 구축
□ 알림 규칙 설정
□ 복구 절차 문서화
□ 테스트 시나리오 작성
□ 팀 교육 및 훈련
□ 정기 검토 및 개선
```

### 3. 에러 처리 메트릭
```
핵심 지표:
- 에러 발생률 (Error Rate)
- 평균 복구 시간 (MTTR)
- 시스템 가용성 (Availability)
- 사용자 영향도 (User Impact)

부가 지표:
- 에러 분류별 통계
- 복구 성공률
- 예방 조치 효과
- 팀 대응 시간
```
