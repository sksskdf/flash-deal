# 상태 관리 시스템

## 주문 상태 머신

### 상태 전이
```
pending → processing → confirmed → shipped → delivered
   ↓          ↓            ↓           ↓
 failed    failed      cancelled   cancelled
```

### 상태별 허용 작업
```javascript
const orderStateTransitions = {
  pending: ['processing', 'failed', 'cancelled'],
  processing: ['confirmed', 'failed'],
  confirmed: ['shipped', 'cancelled'],
  shipped: ['delivered', 'cancelled'],
  delivered: [],  // 종료 상태
  failed: [],     // 종료 상태
  cancelled: []   // 종료 상태
};

function canTransitionOrder(from, to) {
  return orderStateTransitions[from]?.includes(to) ?? false;
}
```

## 재고 상태 머신

### 재고 레벨 상태
```javascript
const inventoryLevels = {
  HIGH: { threshold: 0.5, color: 'green' },    // 50% 이상
  MID: { threshold: 0.2, color: 'yellow' },     // 20-50%
  LOW: { threshold: 0.0, color: 'red' }        // 20% 미만
};

// 재고 레벨 계산
function calculateInventoryLevel(available, total) {
  const ratio = available / total;
  
  if (ratio >= inventoryLevels.HIGH.threshold) return 'HIGH';
  if (ratio >= inventoryLevels.MID.threshold) return 'MID';
  return 'LOW';
}

// 재고 상태 전이
const inventoryStateTransitions = {
  available: ['reserved', 'soldout'],
  reserved: ['available', 'confirmed', 'released'],
  confirmed: ['sold'],
  sold: [],        // 종료 상태
  soldout: ['available']  // 재입고 시
};
```

## 결제 상태 머신

### 결제 상태 전이
```javascript
const paymentStateTransitions = {
  pending: ['processing', 'failed', 'cancelled'],
  processing: ['completed', 'failed'],
  completed: ['refunded'],
  failed: ['pending'],      // 재시도 가능
  cancelled: [],            // 종료 상태
  refunded: []              // 종료 상태
};

// 결제 상태 업데이트
async function updatePaymentStatus(paymentId, newStatus, reason, metadata) {
  const payment = await db.payments.findOne({ _id: paymentId });
  
  if (!canTransitionPayment(payment.status, newStatus)) {
    throw new Error(`Invalid payment transition: ${payment.status} → ${newStatus}`);
  }
  
  await db.payments.updateOne(
    { _id: paymentId },
    {
      $set: { 
        status: newStatus, 
        updatedAt: new Date(),
        ...metadata 
      },
      $push: {
        statusHistory: {
          from: payment.status,
          to: newStatus,
          timestamp: new Date(),
          reason,
          metadata
        }
      }
    }
  );
}
```

## 배송 상태 머신

### 배송 상태 전이
```javascript
const shippingStateTransitions = {
  pending: ['preparing', 'cancelled'],
  preparing: ['shipped', 'cancelled'],
  shipped: ['in_transit', 'delivered', 'returned'],
  in_transit: ['delivered', 'returned', 'lost'],
  delivered: [],           // 종료 상태
  returned: ['refunded'],  // 환불 처리
  lost: ['investigating'], // 분실 조사
  investigating: ['found', 'compensated'],
  found: ['delivered'],
  compensated: [],         // 종료 상태
  refunded: []             // 종료 상태
};

// 배송 상태 업데이트
async function updateShippingStatus(orderId, newStatus, trackingInfo) {
  const order = await db.orders.findOne({ _id: orderId });
  
  await db.orders.updateOne(
    { _id: orderId },
    {
      $set: { 
        'shipping.status': newStatus,
        'shipping.tracking': trackingInfo,
        updatedAt: new Date()
      },
      $push: {
        shippingHistory: {
          from: order.shipping?.status || 'pending',
          to: newStatus,
          timestamp: new Date(),
          trackingInfo
        }
      }
    }
  );
}
```

## 사용자 세션 상태

### 세션 상태 관리
```javascript
const sessionStates = {
  ACTIVE: 'active',           // 활성 세션
  EXPIRED: 'expired',        // 만료된 세션
  REVOKED: 'revoked',        // 관리자에 의해 취소
  SUSPENDED: 'suspended'     // 보안상 일시 정지
};

// 세션 상태 업데이트
async function updateSessionStatus(sessionId, newStatus, reason) {
  await redis.hset(`session:${sessionId}`, {
    status: newStatus,
    updatedAt: new Date().toISOString(),
    reason
  });
  
  // 만료된 세션은 TTL 설정
  if (newStatus === 'expired') {
    await redis.expire(`session:${sessionId}`, 0);
  }
}
```

## 시스템 헬스 상태

### 시스템 상태 정의
```javascript
const systemHealthStates = {
  HEALTHY: 'healthy',         // 정상
  DEGRADED: 'degraded',       // 성능 저하
  UNHEALTHY: 'unhealthy',     // 비정상
  CRITICAL: 'critical'        // 심각한 장애
};

// 헬스 체크
async function checkSystemHealth() {
  const checks = {
    mongodb: await checkMongoDBHealth(),
    redis: await checkRedisHealth(),
    kafka: await checkKafkaHealth(),
    external: await checkExternalServices()
  };
  
  const overallHealth = calculateOverallHealth(checks);
  
  // 상태 업데이트
  await updateSystemHealth(overallHealth, checks);
  
  return { status: overallHealth, checks };
}
```

## 통합 상태 관리

### 상태 변경 처리
```javascript
// 통합 상태 업데이트
async function updateOrderStatus(orderId, newStatus, reason, actor) {
  const order = await db.orders.findOne({ _id: orderId });
  
  // 주문 상태 검증
  if (!canTransitionOrder(order.status, newStatus)) {
    throw new Error(`Invalid transition: ${order.status} → ${newStatus}`);
  }
  
  const session = await db.startSession();
  
  try {
    await session.withTransaction(async () => {
      // 주문 상태 업데이트
      await db.orders.updateOne(
        { _id: orderId },
        {
          $set: { status: newStatus, updatedAt: new Date() },
          $push: {
            statusHistory: {
              from: order.status,
              to: newStatus,
              timestamp: new Date(),
              reason,
              actor
            }
          }
        },
        { session }
      );
      
      // 연관 상태 업데이트
      if (newStatus === 'confirmed') {
        await updatePaymentStatus(order.paymentId, 'completed', 'Order confirmed');
        await updateInventoryStatus(order.items, 'confirmed');
      }
      
      if (newStatus === 'shipped') {
        await updateShippingStatus(orderId, 'shipped', { carrier: 'UPS' });
      }
    });
    
    // 이벤트 발행
    await kafka.send({
      topic: 'orders.updated',
      value: {
        orderId,
        oldStatus: order.status,
        newStatus,
        reason,
        timestamp: new Date().toISOString()
      }
    });
    
  } finally {
    await session.endSession();
  }
}
```

## 상태 모니터링

### 상태 변경 알림
```javascript
// 상태 변경 알림 설정
const statusNotifications = {
  order: {
    'pending → processing': ['customer', 'admin'],
    'processing → confirmed': ['customer', 'admin', 'inventory'],
    'confirmed → shipped': ['customer', 'logistics'],
    'shipped → delivered': ['customer', 'fulfillment']
  },
  payment: {
    'pending → completed': ['customer', 'finance'],
    'completed → refunded': ['customer', 'finance']
  },
  inventory: {
    'HIGH → MID': ['admin', 'procurement'],
    'MID → LOW': ['admin', 'procurement', 'alert'],
    'LOW → SOLDOUT': ['admin', 'marketing', 'alert']
  }
};

// 알림 발송
async function sendStatusNotification(entity, oldStatus, newStatus, data) {
  const notificationKey = `${entity}:${oldStatus} → ${newStatus}`;
  const recipients = statusNotifications[entity]?.[notificationKey];
  
  if (recipients) {
    for (const recipient of recipients) {
      await sendNotification(recipient, {
        entity,
        oldStatus,
        newStatus,
        data,
        timestamp: new Date()
      });
    }
  }
}
```