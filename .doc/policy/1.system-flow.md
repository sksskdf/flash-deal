# 시스템 플로우

## 재고 감소 플로우

### 낙관적 접근 (기본)
```
1. 주문 요청
   └→ GraphQL Mutation: createOrder(productId, quantity)

2. Redis 재고 감소
   ├→ GET inventory:{productId}
   ├→ if stock >= quantity
   │  └→ DECRBY inventory:{productId} {quantity}
   │     └→ 성공: 주문 생성
   └→ else: "품절" 응답

3. 주문 생성
   ├→ MongoDB: Order 생성 (status: pending)
   ├→ Redis: 예약 기록 (10분 TTL)
   └→ Kafka: OrderCreated 이벤트

4. 비동기 처리
   ├→ 결제 성공: Order.confirmed
   └→ 결제 실패: 재고 복구 (INCRBY)
```

### 비관적 접근 (분산 락)
```
1. 락 획득
   └→ SET inventory:lock:{productId} {uuid} NX EX 10

2. 재고 확인 및 감소
   ├→ GET inventory:{productId}
   └→ DECRBY inventory:{productId} {quantity}

3. 주문 생성 (동일)

4. 락 해제
   └→ DEL inventory:lock:{productId}
```

## 주문 생성 플로우

### 성공 시나리오
```
1. 주문 검증 (동기)
   ├→ 멱등성 키 확인
   ├→ 재고 확인 (Redis)
   └→ 주문 생성 (MongoDB)

2. 이벤트 발행 (비동기)
   ├→ Kafka: OrderCreated
   └→ Kafka: InventoryReserveRequested

3. Consumer 처리
   ├→ Inventory: 재고 감소
   ├→ Payment: 결제 처리
   └→ Notification: 알림 발송
```

### 실패 시나리오
```
1. 재고 부족
   └→ 즉시 "품절" 응답

2. 결제 실패
   ├→ 재고 복구 (INCRBY)
   └→ Order.status = "failed"

3. 타임아웃
   ├→ TTL 만료 → 자동 복구
   └→ Scheduled Job → 정리
```

